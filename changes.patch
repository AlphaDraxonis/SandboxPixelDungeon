From 842d76240733a2d5c6b2b9f81b3cf3d10b0fd532 Mon Sep 17 00:00:00 2001
From: Ich <jokist1901@gmail.com>
Date: Mon, 17 Apr 2023 19:07:35 +0200
Subject: [PATCH 1/5] Set to default configuration

---
 build.gradle                                              | 8 ++++----
 .../com/shatteredpixel/shatteredpixeldungeon/Dungeon.java | 5 +++++
 desktop/build.gradle                                      | 2 +-
 3 files changed, 10 insertions(+), 5 deletions(-)

diff --git a/build.gradle b/build.gradle
index 9c95d5362..1c451137c 100644
--- a/build.gradle
+++ b/build.gradle
@@ -4,17 +4,17 @@ buildscript {
         mavenCentral()
     }
     dependencies {
-        classpath 'com.android.tools.build:gradle:7.4.2'
+        classpath 'com.android.tools.build:gradle:7.3.1'
     }
 }
 
 allprojects {
 
     ext {
-        appName = 'Shattered Pixel Dungeon'
-        appPackageName = 'com.shatteredpixel.shatteredpixeldungeon'
+        appName = 'Sandbox Pixel Dungeon'
+        appPackageName = 'com.shatteredpixel.sandbox'
 
-        appVersionCode = 700
+        appVersionCode = 701
         appVersionName = '2.0.2'
 
         appJavaCompatibility = JavaVersion.VERSION_1_8
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
index ba7b4db54..0c262db2c 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
@@ -92,6 +92,11 @@ import java.util.TimeZone;
 
 public class Dungeon {
 
+	static{
+		System.out.println("Test");
+	}
+
+
 	//enum of items which have limited spawns, records how many have spawned
 	//could all be their own separate numbers, but this allows iterating, much nicer for bundling/initializing.
 	public static enum LimitedDrops {
diff --git a/desktop/build.gradle b/desktop/build.gradle
index 97f35f7ac..48d86b0ad 100644
--- a/desktop/build.gradle
+++ b/desktop/build.gradle
@@ -121,6 +121,6 @@ dependencies {
     implementation "org.lwjgl:lwjgl-tinyfd:3.3.1:natives-linux"
     implementation "org.lwjgl:lwjgl-tinyfd:3.3.1:natives-linux-arm64"
 
-    implementation project(':services:updates:githubUpdates')
+    implementation project(':services:updates:debugUpdates')
     implementation project(':services:news:shatteredNews')
 }
\ No newline at end of file
-- 
2.37.1.windows.1


From f0c872e3296b6de7bc2afcb29752ed30454b4cb0 Mon Sep 17 00:00:00 2001
From: Ich <jokist1901@gmail.com>
Date: Mon, 17 Apr 2023 19:44:49 +0200
Subject: [PATCH 2/5] Changed start scene

---
 .../src/main/java/com/watabou/noosa/Game.java |  2 +
 changes.patch                                 | 69 +++++++++++++++++++
 .../shatteredpixeldungeon/Dungeon.java        |  4 --
 .../ShatteredPixelDungeon.java                |  3 +-
 4 files changed, 73 insertions(+), 5 deletions(-)
 create mode 100644 changes.patch

diff --git a/SPD-classes/src/main/java/com/watabou/noosa/Game.java b/SPD-classes/src/main/java/com/watabou/noosa/Game.java
index 23194ace6..9d978f961 100644
--- a/SPD-classes/src/main/java/com/watabou/noosa/Game.java
+++ b/SPD-classes/src/main/java/com/watabou/noosa/Game.java
@@ -224,6 +224,8 @@ public class Game implements ApplicationListener {
 		instance.sceneClass = c;
 		instance.requestedReset = true;
 		instance.onChange = callback;
+		String s = sceneClass.getName();
+		s.length();
 	}
 	
 	public static Scene scene() {
diff --git a/changes.patch b/changes.patch
new file mode 100644
index 000000000..88ee3e38d
--- /dev/null
+++ b/changes.patch
@@ -0,0 +1,69 @@
+From 842d76240733a2d5c6b2b9f81b3cf3d10b0fd532 Mon Sep 17 00:00:00 2001
+From: Ich <jokist1901@gmail.com>
+Date: Mon, 17 Apr 2023 19:07:35 +0200
+Subject: [PATCH] Set to default configuration
+
+---
+ build.gradle                                              | 8 ++++----
+ .../com/shatteredpixel/shatteredpixeldungeon/Dungeon.java | 5 +++++
+ desktop/build.gradle                                      | 2 +-
+ 3 files changed, 10 insertions(+), 5 deletions(-)
+
+diff --git a/build.gradle b/build.gradle
+index 9c95d5362..1c451137c 100644
+--- a/build.gradle
++++ b/build.gradle
+@@ -4,17 +4,17 @@ buildscript {
+         mavenCentral()
+     }
+     dependencies {
+-        classpath 'com.android.tools.build:gradle:7.4.2'
++        classpath 'com.android.tools.build:gradle:7.3.1'
+     }
+ }
+ 
+ allprojects {
+ 
+     ext {
+-        appName = 'Shattered Pixel Dungeon'
+-        appPackageName = 'com.shatteredpixel.shatteredpixeldungeon'
++        appName = 'Sandbox Pixel Dungeon'
++        appPackageName = 'com.shatteredpixel.sandbox'
+ 
+-        appVersionCode = 700
++        appVersionCode = 701
+         appVersionName = '2.0.2'
+ 
+         appJavaCompatibility = JavaVersion.VERSION_1_8
+diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+index ba7b4db54..0c262db2c 100644
+--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
++++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+@@ -92,6 +92,11 @@ import java.util.TimeZone;
+ 
+ public class Dungeon {
+ 
++	static{
++		System.out.println("Test");
++	}
++
++
+ 	//enum of items which have limited spawns, records how many have spawned
+ 	//could all be their own separate numbers, but this allows iterating, much nicer for bundling/initializing.
+ 	public static enum LimitedDrops {
+diff --git a/desktop/build.gradle b/desktop/build.gradle
+index 97f35f7ac..48d86b0ad 100644
+--- a/desktop/build.gradle
++++ b/desktop/build.gradle
+@@ -121,6 +121,6 @@ dependencies {
+     implementation "org.lwjgl:lwjgl-tinyfd:3.3.1:natives-linux"
+     implementation "org.lwjgl:lwjgl-tinyfd:3.3.1:natives-linux-arm64"
+ 
+-    implementation project(':services:updates:githubUpdates')
++    implementation project(':services:updates:debugUpdates')
+     implementation project(':services:news:shatteredNews')
+ }
+\ No newline at end of file
+-- 
+2.37.1.windows.1
+
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
index 0c262db2c..41a1230e6 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
@@ -92,10 +92,6 @@ import java.util.TimeZone;
 
 public class Dungeon {
 
-	static{
-		System.out.println("Test");
-	}
-
 
 	//enum of items which have limited spawns, records how many have spawned
 	//could all be their own separate numbers, but this allows iterating, much nicer for bundling/initializing.
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
index 9fd96986c..6b43a7728 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
@@ -43,7 +43,7 @@ public class ShatteredPixelDungeon extends Game {
 	public static final int v2_0_0  = 684;
 	
 	public ShatteredPixelDungeon( PlatformSupport platform ) {
-		super( sceneClass == null ? WelcomeScene.class : sceneClass, platform );
+		super( sceneClass == null ? TitleScene.class : sceneClass, platform );
 
 		//pre-v1.3.0
 		com.watabou.utils.Bundle.addAlias(
@@ -95,6 +95,7 @@ public class ShatteredPixelDungeon extends Game {
 	}
 
 	public static void switchNoFade(Class<? extends PixelScene> c, SceneChangeCallback callback) {
+		System.out.println(c.getSimpleName());
 		PixelScene.noFade = true;
 		switchScene( c, callback );
 	}
-- 
2.37.1.windows.1


From c1106cd282e817befacc616e980063350e86f04a Mon Sep 17 00:00:00 2001
From: Ich <jokist1901@gmail.com>
Date: Mon, 17 Apr 2023 19:49:14 +0200
Subject: [PATCH 3/5] New Class

---
 changes.patch                                 | 143 +++++++++++++++++-
 .../levels/editor/CustomTestLevel.java        |  19 +++
 2 files changed, 161 insertions(+), 1 deletion(-)
 create mode 100644 core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java

diff --git a/changes.patch b/changes.patch
index 88ee3e38d..2f1c228f4 100644
--- a/changes.patch
+++ b/changes.patch
@@ -1,7 +1,7 @@
 From 842d76240733a2d5c6b2b9f81b3cf3d10b0fd532 Mon Sep 17 00:00:00 2001
 From: Ich <jokist1901@gmail.com>
 Date: Mon, 17 Apr 2023 19:07:35 +0200
-Subject: [PATCH] Set to default configuration
+Subject: [PATCH 1/2] Set to default configuration
 
 ---
  build.gradle                                              | 8 ++++----
@@ -67,3 +67,144 @@ index 97f35f7ac..48d86b0ad 100644
 -- 
 2.37.1.windows.1
 
+
+From f0c872e3296b6de7bc2afcb29752ed30454b4cb0 Mon Sep 17 00:00:00 2001
+From: Ich <jokist1901@gmail.com>
+Date: Mon, 17 Apr 2023 19:44:49 +0200
+Subject: [PATCH 2/2] Changed start scene
+
+---
+ .../src/main/java/com/watabou/noosa/Game.java |  2 +
+ changes.patch                                 | 69 +++++++++++++++++++
+ .../shatteredpixeldungeon/Dungeon.java        |  4 --
+ .../ShatteredPixelDungeon.java                |  3 +-
+ 4 files changed, 73 insertions(+), 5 deletions(-)
+ create mode 100644 changes.patch
+
+diff --git a/SPD-classes/src/main/java/com/watabou/noosa/Game.java b/SPD-classes/src/main/java/com/watabou/noosa/Game.java
+index 23194ace6..9d978f961 100644
+--- a/SPD-classes/src/main/java/com/watabou/noosa/Game.java
++++ b/SPD-classes/src/main/java/com/watabou/noosa/Game.java
+@@ -224,6 +224,8 @@ public class Game implements ApplicationListener {
+ 		instance.sceneClass = c;
+ 		instance.requestedReset = true;
+ 		instance.onChange = callback;
++		String s = sceneClass.getName();
++		s.length();
+ 	}
+ 	
+ 	public static Scene scene() {
+diff --git a/changes.patch b/changes.patch
+new file mode 100644
+index 000000000..88ee3e38d
+--- /dev/null
++++ b/changes.patch
+@@ -0,0 +1,69 @@
++From 842d76240733a2d5c6b2b9f81b3cf3d10b0fd532 Mon Sep 17 00:00:00 2001
++From: Ich <jokist1901@gmail.com>
++Date: Mon, 17 Apr 2023 19:07:35 +0200
++Subject: [PATCH] Set to default configuration
++
++---
++ build.gradle                                              | 8 ++++----
++ .../com/shatteredpixel/shatteredpixeldungeon/Dungeon.java | 5 +++++
++ desktop/build.gradle                                      | 2 +-
++ 3 files changed, 10 insertions(+), 5 deletions(-)
++
++diff --git a/build.gradle b/build.gradle
++index 9c95d5362..1c451137c 100644
++--- a/build.gradle
+++++ b/build.gradle
++@@ -4,17 +4,17 @@ buildscript {
++         mavenCentral()
++     }
++     dependencies {
++-        classpath 'com.android.tools.build:gradle:7.4.2'
+++        classpath 'com.android.tools.build:gradle:7.3.1'
++     }
++ }
++ 
++ allprojects {
++ 
++     ext {
++-        appName = 'Shattered Pixel Dungeon'
++-        appPackageName = 'com.shatteredpixel.shatteredpixeldungeon'
+++        appName = 'Sandbox Pixel Dungeon'
+++        appPackageName = 'com.shatteredpixel.sandbox'
++ 
++-        appVersionCode = 700
+++        appVersionCode = 701
++         appVersionName = '2.0.2'
++ 
++         appJavaCompatibility = JavaVersion.VERSION_1_8
++diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
++index ba7b4db54..0c262db2c 100644
++--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+++++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
++@@ -92,6 +92,11 @@ import java.util.TimeZone;
++ 
++ public class Dungeon {
++ 
+++	static{
+++		System.out.println("Test");
+++	}
+++
+++
++ 	//enum of items which have limited spawns, records how many have spawned
++ 	//could all be their own separate numbers, but this allows iterating, much nicer for bundling/initializing.
++ 	public static enum LimitedDrops {
++diff --git a/desktop/build.gradle b/desktop/build.gradle
++index 97f35f7ac..48d86b0ad 100644
++--- a/desktop/build.gradle
+++++ b/desktop/build.gradle
++@@ -121,6 +121,6 @@ dependencies {
++     implementation "org.lwjgl:lwjgl-tinyfd:3.3.1:natives-linux"
++     implementation "org.lwjgl:lwjgl-tinyfd:3.3.1:natives-linux-arm64"
++ 
++-    implementation project(':services:updates:githubUpdates')
+++    implementation project(':services:updates:debugUpdates')
++     implementation project(':services:news:shatteredNews')
++ }
++\ No newline at end of file
++-- 
++2.37.1.windows.1
++
+diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+index 0c262db2c..41a1230e6 100644
+--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
++++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+@@ -92,10 +92,6 @@ import java.util.TimeZone;
+ 
+ public class Dungeon {
+ 
+-	static{
+-		System.out.println("Test");
+-	}
+-
+ 
+ 	//enum of items which have limited spawns, records how many have spawned
+ 	//could all be their own separate numbers, but this allows iterating, much nicer for bundling/initializing.
+diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
+index 9fd96986c..6b43a7728 100644
+--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
++++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/ShatteredPixelDungeon.java
+@@ -43,7 +43,7 @@ public class ShatteredPixelDungeon extends Game {
+ 	public static final int v2_0_0  = 684;
+ 	
+ 	public ShatteredPixelDungeon( PlatformSupport platform ) {
+-		super( sceneClass == null ? WelcomeScene.class : sceneClass, platform );
++		super( sceneClass == null ? TitleScene.class : sceneClass, platform );
+ 
+ 		//pre-v1.3.0
+ 		com.watabou.utils.Bundle.addAlias(
+@@ -95,6 +95,7 @@ public class ShatteredPixelDungeon extends Game {
+ 	}
+ 
+ 	public static void switchNoFade(Class<? extends PixelScene> c, SceneChangeCallback callback) {
++		System.out.println(c.getSimpleName());
+ 		PixelScene.noFade = true;
+ 		switchScene( c, callback );
+ 	}
+-- 
+2.37.1.windows.1
+
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
new file mode 100644
index 000000000..e666e28d7
--- /dev/null
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
@@ -0,0 +1,19 @@
+package com.shatteredpixel.shatteredpixeldungeon.levels.editor;
+
+import com.shatteredpixel.shatteredpixeldungeon.levels.Level;
+
+public class CustomTestLevel extends Level {
+    @Override
+    protected boolean build() {
+        return false;
+    }
+
+    @Override
+    protected void createMobs() {
+
+    }
+
+    @Override
+    protected void createItems() {
+    }
+}
-- 
2.37.1.windows.1


From 3d952dcf796a36bbf5b06c843749228e3a118de1 Mon Sep 17 00:00:00 2001
From: Ich <jokist1901@gmail.com>
Date: Mon, 17 Apr 2023 21:19:55 +0200
Subject: [PATCH 4/5] some changes

---
 .../shatteredpixeldungeon/Dungeon.java        |  99 ++++++++--------
 .../levels/editor/CustomTestLevel.java        | 108 +++++++++++++++++-
 .../scenes/InterlevelScene.java               |   3 +
 3 files changed, 160 insertions(+), 50 deletions(-)

diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
index 41a1230e6..e5f1303fc 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
@@ -63,6 +63,7 @@ import com.shatteredpixel.shatteredpixeldungeon.levels.PrisonLevel;
 import com.shatteredpixel.shatteredpixeldungeon.levels.RegularLevel;
 import com.shatteredpixel.shatteredpixeldungeon.levels.SewerBossLevel;
 import com.shatteredpixel.shatteredpixeldungeon.levels.SewerLevel;
+import com.shatteredpixel.shatteredpixeldungeon.levels.editor.CustomTestLevel;
 import com.shatteredpixel.shatteredpixeldungeon.levels.features.LevelTransition;
 import com.shatteredpixel.shatteredpixeldungeon.levels.rooms.secret.SecretRoom;
 import com.shatteredpixel.shatteredpixeldungeon.levels.rooms.special.SpecialRoom;
@@ -290,56 +291,56 @@ public class Dungeon {
 		Level level;
 		if (branch == 0) {
 			switch (depth) {
-				case 1:
-				case 2:
-				case 3:
-				case 4:
-					level = new SewerLevel();
-					break;
-				case 5:
-					level = new SewerBossLevel();
-					break;
-				case 6:
-				case 7:
-				case 8:
-				case 9:
-					level = new PrisonLevel();
-					break;
-				case 10:
-					level = new PrisonBossLevel();
-					break;
-				case 11:
-				case 12:
-				case 13:
-				case 14:
-					level = new CavesLevel();
-					break;
-				case 15:
-					level = new CavesBossLevel();
-					break;
-				case 16:
-				case 17:
-				case 18:
-				case 19:
-					level = new CityLevel();
-					break;
-				case 20:
-					level = new CityBossLevel();
-					break;
-				case 21:
-				case 22:
-				case 23:
-				case 24:
-					level = new HallsLevel();
-					break;
-				case 25:
-					level = new HallsBossLevel();
-					break;
-				case 26:
-					level = new LastLevel();
-					break;
+//				case 1:
+//				case 2:
+//				case 3:
+//				case 4:
+//					level = new SewerLevel();
+//					break;
+//				case 5:
+//					level = new SewerBossLevel();
+//					break;
+//				case 6:
+//				case 7:
+//				case 8:
+//				case 9:
+//					level = new PrisonLevel();
+//					break;
+//				case 10:
+//					level = new PrisonBossLevel();
+//					break;
+//				case 11:
+//				case 12:
+//				case 13:
+//				case 14:
+//					level = new CavesLevel();
+//					break;
+//				case 15:
+//					level = new CavesBossLevel();
+//					break;
+//				case 16:
+//				case 17:
+//				case 18:
+//				case 19:
+//					level = new CityLevel();
+//					break;
+//				case 20:
+//					level = new CityBossLevel();
+//					break;
+//				case 21:
+//				case 22:
+//				case 23:
+//				case 24:
+//					level = new HallsLevel();
+//					break;
+//				case 25:
+//					level = new HallsBossLevel();
+//					break;
+//				case 26:
+//					level = new LastLevel();
+//					break;
 				default:
-					level = new DeadEndLevel();
+					level = new CustomTestLevel();
 					Statistics.deepestFloor--;
 			}
 		} else {
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
index e666e28d7..4305dfa4a 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
@@ -1,19 +1,125 @@
 package com.shatteredpixel.shatteredpixeldungeon.levels.editor;
 
+import com.shatteredpixel.shatteredpixeldungeon.Assets;
+import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;
+import com.shatteredpixel.shatteredpixeldungeon.actors.Char;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DwarfKing;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Goo;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Rat;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Scorpio;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.YogDzewa;
+import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.npcs.Imp;
+import com.shatteredpixel.shatteredpixeldungeon.items.Torch;
 import com.shatteredpixel.shatteredpixeldungeon.levels.Level;
 
+import static com.shatteredpixel.shatteredpixeldungeon.levels.Terrain.*;
+
+import com.shatteredpixel.shatteredpixeldungeon.levels.Terrain;
+import com.shatteredpixel.shatteredpixeldungeon.levels.features.LevelTransition;
+import com.watabou.utils.Point;
+
 public class CustomTestLevel extends Level {
+
+    private final int width = 10, height = 10;
+    private  final  int[] terrains = {
+            WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL,
+            WALL, WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, WATER, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WATER, EMPTY, WALL,
+            WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, ENTRANCE, EMPTY, WALL,
+            WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, WALL, WALL, WALL, WALL, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, EXIT, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL
+    };
+
+
+    {
+        color1 = 0x534f3e;
+        color2 = 0xb9d661;
+    }
+
+    @Override
+    public String tilesTex() {
+        return Assets.Environment.TILES_SEWERS;
+    }
+
+    @Override
+    public String waterTex() {
+        return Assets.Environment.WATER_PRISON;
+    }
+
     @Override
     protected boolean build() {
-        return false;
+
+        setSize(width, height);
+
+
+        for (int i = 0; i < terrains.length; i++) {
+            map[i] = terrains[i];
+        }
+
+        addTransitios();
+
+        return true;
+    }
+    protected  void  addTransitios(){
+        for (int i = 0; i < terrains.length; i++) {
+            if (terrains[i] == ENTRANCE) transitions.add(new LevelTransition(this, i,LevelTransition.Type.SURFACE));
+            else if (terrains[i] == EXIT) transitions.add(new LevelTransition(this, i,LevelTransition.Type.REGULAR_EXIT));
+        }
+    }
+
+    @Override
+    public Mob createMob() {
+        return null;
     }
 
     @Override
     protected void createMobs() {
+       Mob m1 = new Rat();
+       m1.pos=25;
+       mobs.add(m1);
+
+        Mob m2 = new Imp();
+        m2.pos=45;
+        mobs.add(m2);
+        Mob m3 = new Scorpio();
+        m3.pos=83;
+
+        m3.paralysed=5000;
+        m3.invisible=10;
+        m3.damage(50,null);
 
+        mobs.add(m3);
+    }
+
+
+    public Actor addRespawner() {
+        return null;
     }
 
     @Override
     protected void createItems() {
+
+        drop(new Torch(),21);
+
+
+    }
+
+    @Override
+    public int randomRespawnCell(Char ch) {
+        return entrance() - width();
+    }
+
+
+    public int getWidth() {
+        return width;
+    }
+
+    public int getHeight() {
+        return height;
     }
 }
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java
index 21e9449f1..324bc904a 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java
@@ -32,8 +32,10 @@ import com.shatteredpixel.shatteredpixeldungeon.actors.buffs.Buff;
 import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.Mob;
 import com.shatteredpixel.shatteredpixeldungeon.items.Item;
 import com.shatteredpixel.shatteredpixeldungeon.items.LostBackpack;
+import com.shatteredpixel.shatteredpixeldungeon.levels.DeadEndLevel;
 import com.shatteredpixel.shatteredpixeldungeon.levels.Level;
 import com.shatteredpixel.shatteredpixeldungeon.levels.Terrain;
+import com.shatteredpixel.shatteredpixeldungeon.levels.editor.CustomTestLevel;
 import com.shatteredpixel.shatteredpixeldungeon.levels.features.Chasm;
 import com.shatteredpixel.shatteredpixeldungeon.levels.features.LevelTransition;
 import com.shatteredpixel.shatteredpixeldungeon.levels.rooms.special.SpecialRoom;
@@ -377,6 +379,7 @@ public class InterlevelScene extends PixelScene {
 			GameLog.wipe();
 
 			Level level = Dungeon.newLevel();
+
 			Dungeon.switchLevel( level, -1 );
 		} else {
 			Mob.holdAllies( Dungeon.level );
-- 
2.37.1.windows.1


From 18ae36b0e5f08201645cdebcb6fe5e6dfb6a90d4 Mon Sep 17 00:00:00 2001
From: Ich <jokist1901@gmail.com>
Date: Mon, 17 Apr 2023 22:08:41 +0200
Subject: [PATCH 5/5] some changes

---
 .../shatteredpixeldungeon/Dungeon.java        |    7 +-
 .../actors/hero/Hero.java                     |    2 +-
 .../shatteredpixeldungeon/levels/Level.java   | 2816 +++++++++--------
 .../levels/editor/CustomTestLevel.java        |   52 +-
 .../scenes/InterlevelScene.java               |    3 +
 5 files changed, 1452 insertions(+), 1428 deletions(-)

diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
index e5f1303fc..972e4db66 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/Dungeon.java
@@ -94,6 +94,8 @@ import java.util.TimeZone;
 public class Dungeon {
 
 
+	public  static  final  int MAX_DEPTH=50;
+
 	//enum of items which have limited spawns, records how many have spawned
 	//could all be their own separate numbers, but this allows iterating, much nicer for bundling/initializing.
 	public static enum LimitedDrops {
@@ -183,6 +185,7 @@ public class Dungeon {
 	// 0 is the default path
 	// Other numbers are currently unused
 	public static int branch;
+	public  static  int prevBranch;
 
 	public static int gold;
 	public static int energy;
@@ -344,7 +347,7 @@ public class Dungeon {
 					Statistics.deepestFloor--;
 			}
 		} else {
-			level = new DeadEndLevel();
+			level = new CustomTestLevel();
 			Statistics.deepestFloor--;
 		}
 		
@@ -716,7 +719,7 @@ public class Dungeon {
 		Generator.restoreFromBundle( bundle );
 
 		droppedItems = new SparseArray<>();
-		for (int i=1; i <= 26; i++) {
+		for (int i=1; i <= MAX_DEPTH; i++) {
 			
 			//dropped items
 			ArrayList<Item> items = new ArrayList<>();
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java
index 7dffb55b9..a9c589735 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/actors/hero/Hero.java
@@ -1650,7 +1650,7 @@ public class Hero extends Char {
 				//moving to a transition doesn't automatically trigger it when enemies are near
 				&& (visibleEnemies.size() == 0 || cell == pos)
 				&& !Dungeon.level.locked
-				&& (Dungeon.depth < 26 || Dungeon.level.getTransition(cell).type == LevelTransition.Type.REGULAR_ENTRANCE) ) {
+				&& (Dungeon.depth < Dungeon.MAX_DEPTH || Dungeon.level.getTransition(cell).type == LevelTransition.Type.REGULAR_ENTRANCE) ) {
 
 			curAction = new HeroAction.LvlTransition( cell );
 			
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java
index c874e32f1..f17a2111a 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/Level.java
@@ -101,1411 +101,1413 @@ import java.util.HashMap;
 import java.util.HashSet;
 
 public abstract class Level implements Bundlable {
-	
-	public static enum Feeling {
-		NONE,
-		CHASM,
-		WATER,
-		GRASS,
-		DARK,
-		LARGE,
-		TRAPS,
-		SECRETS
-	}
-
-	protected int width;
-	protected int height;
-	protected int length;
-	
-	protected static final float TIME_TO_RESPAWN	= 50;
-
-	public int version;
-	
-	public int[] map;
-	public boolean[] visited;
-	public boolean[] mapped;
-	public boolean[] discoverable;
-
-	public int viewDistance = Dungeon.isChallenged( Challenges.DARKNESS ) ? 2 : 8;
-	
-	public boolean[] heroFOV;
-	
-	public boolean[] passable;
-	public boolean[] losBlocking;
-	public boolean[] flamable;
-	public boolean[] secret;
-	public boolean[] solid;
-	public boolean[] avoid;
-	public boolean[] water;
-	public boolean[] pit;
-
-	public boolean[] openSpace;
-	
-	public Feeling feeling = Feeling.NONE;
-	
-	public int entrance;
-	public int exit;
-
-	public ArrayList<LevelTransition> transitions;
-
-	//when a boss level has become locked.
-	public boolean locked = false;
-	
-	public HashSet<Mob> mobs;
-	public SparseArray<Heap> heaps;
-	public HashMap<Class<? extends Blob>,Blob> blobs;
-	public SparseArray<Plant> plants;
-	public SparseArray<Trap> traps;
-	public HashSet<CustomTilemap> customTiles;
-	public HashSet<CustomTilemap> customWalls;
-	
-	protected ArrayList<Item> itemsToSpawn = new ArrayList<>();
-
-	protected Group visuals;
-	
-	public int color1 = 0x004400;
-	public int color2 = 0x88CC44;
-
-	private static final String VERSION     = "version";
-	private static final String WIDTH       = "width";
-	private static final String HEIGHT      = "height";
-	private static final String MAP			= "map";
-	private static final String VISITED		= "visited";
-	private static final String MAPPED		= "mapped";
-	private static final String TRANSITIONS	= "transitions";
-	private static final String LOCKED      = "locked";
-	private static final String HEAPS		= "heaps";
-	private static final String PLANTS		= "plants";
-	private static final String TRAPS       = "traps";
-	private static final String CUSTOM_TILES= "customTiles";
-	private static final String CUSTOM_WALLS= "customWalls";
-	private static final String MOBS		= "mobs";
-	private static final String BLOBS		= "blobs";
-	private static final String FEELING		= "feeling";
-
-	public void create() {
-
-		Random.pushGenerator( Dungeon.seedCurDepth() );
-		
-		if (!(Dungeon.bossLevel())) {
-
-			addItemToSpawn(Generator.random(Generator.Category.FOOD));
-
-			if (Dungeon.isChallenged(Challenges.DARKNESS)){
-				addItemToSpawn( new Torch() );
-			}
-
-			if (Dungeon.posNeeded()) {
-				addItemToSpawn( new PotionOfStrength() );
-				Dungeon.LimitedDrops.STRENGTH_POTIONS.count++;
-			}
-			if (Dungeon.souNeeded()) {
-				addItemToSpawn( new ScrollOfUpgrade() );
-				Dungeon.LimitedDrops.UPGRADE_SCROLLS.count++;
-			}
-			if (Dungeon.asNeeded()) {
-				addItemToSpawn( new Stylus() );
-				Dungeon.LimitedDrops.ARCANE_STYLI.count++;
-			}
-			//one scroll of transmutation is guaranteed to spawn somewhere on chapter 2-4
-			int enchChapter = (int)((Dungeon.seed / 10) % 3) + 1;
-			if ( Dungeon.depth / 5 == enchChapter &&
-					Dungeon.seed % 4 + 1 == Dungeon.depth % 5){
-				addItemToSpawn( new StoneOfEnchantment() );
-			}
-			
-			if ( Dungeon.depth == ((Dungeon.seed % 3) + 1)){
-				addItemToSpawn( new StoneOfIntuition() );
-			}
-			
-			if (Dungeon.depth > 1) {
-				//50% chance of getting a level feeling
-				//~7.15% chance for each feeling
-				switch (Random.Int( 14 )) {
-					case 0:
-						feeling = Feeling.CHASM;
-						break;
-					case 1:
-						feeling = Feeling.WATER;
-						break;
-					case 2:
-						feeling = Feeling.GRASS;
-						break;
-					case 3:
-						feeling = Feeling.DARK;
-						addItemToSpawn(new Torch());
-						viewDistance = Math.round(viewDistance/2f);
-						break;
-					case 4:
-						feeling = Feeling.LARGE;
-						addItemToSpawn(Generator.random(Generator.Category.FOOD));
-						//add a second torch to help with the larger floor
-						if (Dungeon.isChallenged(Challenges.DARKNESS)){
-							addItemToSpawn( new Torch() );
-						}
-						break;
-					case 5:
-						feeling = Feeling.TRAPS;
-						break;
-					case 6:
-						feeling = Feeling.SECRETS;
-						break;
-				}
-			}
-		}
-		
-		do {
-			width = height = length = 0;
-
-			transitions = new ArrayList<>();
-
-			mobs = new HashSet<>();
-			heaps = new SparseArray<>();
-			blobs = new HashMap<>();
-			plants = new SparseArray<>();
-			traps = new SparseArray<>();
-			customTiles = new HashSet<>();
-			customWalls = new HashSet<>();
-			
-		} while (!build());
-		
-		buildFlagMaps();
-		cleanWalls();
-		
-		createMobs();
-		createItems();
-
-		Random.popGenerator();
-	}
-	
-	public void setSize(int w, int h){
-		
-		width = w;
-		height = h;
-		length = w * h;
-		
-		map = new int[length];
-		Arrays.fill( map, feeling == Level.Feeling.CHASM ? Terrain.CHASM : Terrain.WALL );
-		
-		visited     = new boolean[length];
-		mapped      = new boolean[length];
-		
-		heroFOV     = new boolean[length];
-		
-		passable	= new boolean[length];
-		losBlocking	= new boolean[length];
-		flamable	= new boolean[length];
-		secret		= new boolean[length];
-		solid		= new boolean[length];
-		avoid		= new boolean[length];
-		water		= new boolean[length];
-		pit			= new boolean[length];
-
-		openSpace   = new boolean[length];
-		
-		PathFinder.setMapSize(w, h);
-	}
-	
-	public void reset() {
-		
-		for (Mob mob : mobs.toArray( new Mob[0] )) {
-			if (!mob.reset()) {
-				mobs.remove( mob );
-			}
-		}
-		createMobs();
-	}
-
-	public void playLevelMusic(){
-		//do nothing by default
-	}
-	
-	@Override
-	public void restoreFromBundle( Bundle bundle ) {
-
-		version = bundle.getInt( VERSION );
-		
-		//saves from before v1.2.3 are not supported
-		if (version < ShatteredPixelDungeon.v1_2_3){
-			throw new RuntimeException("old save");
-		}
-
-		setSize( bundle.getInt(WIDTH), bundle.getInt(HEIGHT));
-		
-		mobs = new HashSet<>();
-		heaps = new SparseArray<>();
-		blobs = new HashMap<>();
-		plants = new SparseArray<>();
-		traps = new SparseArray<>();
-		customTiles = new HashSet<>();
-		customWalls = new HashSet<>();
-		
-		map		= bundle.getIntArray( MAP );
-
-		visited	= bundle.getBooleanArray( VISITED );
-		mapped	= bundle.getBooleanArray( MAPPED );
-
-		transitions = new ArrayList<>();
-		if (bundle.contains(TRANSITIONS)){
-			for (Bundlable b : bundle.getCollection( TRANSITIONS )){
-				transitions.add((LevelTransition) b);
-			}
-		//pre-1.3.0 saves, converts old entrance/exit to new transitions
-		} else {
-			if (bundle.contains("entrance")){
-				transitions.add(new LevelTransition(
-						this,
-						bundle.getInt("entrance"),
-						Dungeon.depth == 1 ? LevelTransition.Type.SURFACE : LevelTransition.Type.REGULAR_ENTRANCE));
-			}
-			if (bundle.contains("exit")){
-				transitions.add(new LevelTransition(this, bundle.getInt("exit"), LevelTransition.Type.REGULAR_EXIT));
-			}
-		}
-
-		locked      = bundle.getBoolean( LOCKED );
-		
-		Collection<Bundlable> collection = bundle.getCollection( HEAPS );
-		for (Bundlable h : collection) {
-			Heap heap = (Heap)h;
-			if (!heap.isEmpty())
-				heaps.put( heap.pos, heap );
-		}
-		
-		collection = bundle.getCollection( PLANTS );
-		for (Bundlable p : collection) {
-			Plant plant = (Plant)p;
-			plants.put( plant.pos, plant );
-		}
-
-		collection = bundle.getCollection( TRAPS );
-		for (Bundlable p : collection) {
-			Trap trap = (Trap)p;
-			traps.put( trap.pos, trap );
-		}
-
-		collection = bundle.getCollection( CUSTOM_TILES );
-		for (Bundlable p : collection) {
-			CustomTilemap vis = (CustomTilemap)p;
-			customTiles.add(vis);
-		}
-
-		collection = bundle.getCollection( CUSTOM_WALLS );
-		for (Bundlable p : collection) {
-			CustomTilemap vis = (CustomTilemap)p;
-			customWalls.add(vis);
-		}
-		
-		collection = bundle.getCollection( MOBS );
-		for (Bundlable m : collection) {
-			Mob mob = (Mob)m;
-			if (mob != null) {
-				mobs.add( mob );
-			}
-		}
-		
-		collection = bundle.getCollection( BLOBS );
-		for (Bundlable b : collection) {
-			Blob blob = (Blob)b;
-			blobs.put( blob.getClass(), blob );
-		}
-
-		feeling = bundle.getEnum( FEELING, Feeling.class );
-		if (feeling == Feeling.DARK)
-			viewDistance = Math.round(viewDistance/2f);
-
-		if (bundle.contains( "mobs_to_spawn" )) {
-			for (Class<? extends Mob> mob : bundle.getClassArray("mobs_to_spawn")) {
-				if (mob != null) mobsToSpawn.add(mob);
-			}
-		}
-
-		if (bundle.contains( "respawner" )){
-			respawner = (Respawner) bundle.get("respawner");
-		}
-
-		buildFlagMaps();
-		cleanWalls();
-
-	}
-	
-	@Override
-	public void storeInBundle( Bundle bundle ) {
-		bundle.put( VERSION, Game.versionCode );
-		bundle.put( WIDTH, width );
-		bundle.put( HEIGHT, height );
-		bundle.put( MAP, map );
-		bundle.put( VISITED, visited );
-		bundle.put( MAPPED, mapped );
-		bundle.put( TRANSITIONS, transitions );
-		bundle.put( LOCKED, locked );
-		bundle.put( HEAPS, heaps.valueList() );
-		bundle.put( PLANTS, plants.valueList() );
-		bundle.put( TRAPS, traps.valueList() );
-		bundle.put( CUSTOM_TILES, customTiles );
-		bundle.put( CUSTOM_WALLS, customWalls );
-		bundle.put( MOBS, mobs );
-		bundle.put( BLOBS, blobs.values() );
-		bundle.put( FEELING, feeling );
-		bundle.put( "mobs_to_spawn", mobsToSpawn.toArray(new Class[0]));
-		bundle.put( "respawner", respawner );
-	}
-	
-	public int tunnelTile() {
-		return feeling == Feeling.CHASM ? Terrain.EMPTY_SP : Terrain.EMPTY;
-	}
-
-	public int width() {
-		return width;
-	}
-
-	public int height() {
-		return height;
-	}
-
-	public int length() {
-		return length;
-	}
-	
-	public String tilesTex() {
-		return null;
-	}
-	
-	public String waterTex() {
-		return null;
-	}
-	
-	abstract protected boolean build();
-	
-	private ArrayList<Class<?extends Mob>> mobsToSpawn = new ArrayList<>();
-	
-	public Mob createMob() {
-		if (mobsToSpawn == null || mobsToSpawn.isEmpty()) {
-			mobsToSpawn = Bestiary.getMobRotation(Dungeon.depth);
-		}
-
-		Mob m = Reflection.newInstance(mobsToSpawn.remove(0));
-		ChampionEnemy.rollForChampion(m);
-		return m;
-	}
-
-	abstract protected void createMobs();
-
-	abstract protected void createItems();
-
-	public int entrance(){
-		LevelTransition l = getTransition(null);
-		if (l != null){
-			return l.cell();
-		}
-		return 0;
-	}
-
-	public int exit(){
-		LevelTransition l = getTransition(LevelTransition.Type.REGULAR_EXIT);
-		if (l != null){
-			return l.cell();
-		}
-		return 0;
-	}
-
-	public LevelTransition getTransition(LevelTransition.Type type){
-		for (LevelTransition transition : transitions){
-			//if we don't specify a type, prefer to return any entrance
-			if (type == null &&
-					(transition.type == LevelTransition.Type.REGULAR_ENTRANCE || transition.type == LevelTransition.Type.SURFACE)){
-				return transition;
-			} else if (transition.type == type){
-				return transition;
-			}
-		}
-		return (type == null && !transitions.isEmpty() ? transitions.get(0) : null);
-	}
-
-	public LevelTransition getTransition(int cell){
-		for (LevelTransition transition : transitions){
-			if (transition.inside(cell)){
-				return transition;
-			}
-		}
-		return null;
-	}
-
-	//some buff effects have special logic or are cancelled from the hero before transitioning levels
-	public static void beforeTransition(){
-
-		//time freeze effects need to resolve their pressed cells before transitioning
-		TimekeepersHourglass.timeFreeze timeFreeze = Dungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);
-		if (timeFreeze != null) timeFreeze.disarmPresses();
-		Swiftthistle.TimeBubble timeBubble = Dungeon.hero.buff(Swiftthistle.TimeBubble.class);
-		if (timeBubble != null) timeBubble.disarmPresses();
-
-		//iron stomach does not persist through chasm falling
-		Talent.WarriorFoodImmunity foodImmune = Dungeon.hero.buff(Talent.WarriorFoodImmunity.class);
-		if (foodImmune != null) foodImmune.detach();
-	}
-
-	public void seal(){
-		if (!locked) {
-			locked = true;
-			Buff.affect(Dungeon.hero, LockedFloor.class);
-		}
-	}
-
-	public void unseal(){
-		if (locked) {
-			locked = false;
-			if (Dungeon.hero.buff(LockedFloor.class) != null){
-				Dungeon.hero.buff(LockedFloor.class).detach();
-			}
-		}
-	}
-
-	public ArrayList<Item> getItemsToPreserveFromSealedResurrect(){
-		ArrayList<Item> items = new ArrayList<>();
-		for (Heap h : heaps.valueList()){
-			if (h.type == Heap.Type.HEAP) items.addAll(h.items);
-		}
-		for (Mob m : mobs){
-			for (PinCushion b : m.buffs(PinCushion.class)){
-				items.addAll(b.getStuckItems());
-			}
-		}
-		for (HeavyBoomerang.CircleBack b : Dungeon.hero.buffs(HeavyBoomerang.CircleBack.class)){
-			if (b.activeDepth() == Dungeon.depth) items.add(b.cancel());
-		}
-		return items;
-	}
-
-	public Group addVisuals() {
-		if (visuals == null || visuals.parent == null){
-			visuals = new Group();
-		} else {
-			visuals.clear();
-			visuals.camera = null;
-		}
-		for (int i=0; i < length(); i++) {
-			if (pit[i]) {
-				visuals.add( new WindParticle.Wind( i ) );
-				if (i >= width() && water[i-width()]) {
-					visuals.add( new FlowParticle.Flow( i - width() ) );
-				}
-			}
-		}
-		return visuals;
-	}
-	
-	public int mobLimit() {
-		return 0;
-	}
-
-	public int mobCount(){
-		float count = 0;
-		for (Mob mob : Dungeon.level.mobs.toArray(new Mob[0])){
-			if (mob.alignment == Char.Alignment.ENEMY && !mob.properties().contains(Char.Property.MINIBOSS)) {
-				count += mob.spawningWeight();
-			}
-		}
-		return Math.round(count);
-	}
-
-	public Mob findMob( int pos ){
-		for (Mob mob : mobs){
-			if (mob.pos == pos){
-				return mob;
-			}
-		}
-		return null;
-	}
-
-	private Respawner respawner;
-
-	public Actor addRespawner() {
-		if (respawner == null){
-			respawner = new Respawner();
-			Actor.addDelayed(respawner, respawnCooldown());
-		} else {
-			Actor.add(respawner);
-			if (respawner.cooldown() > respawnCooldown()){
-				respawner.resetCooldown();
-			}
-		}
-		return respawner;
-	}
-
-	public static class Respawner extends Actor {
-		{
-			actPriority = BUFF_PRIO; //as if it were a buff.
-		}
-
-		@Override
-		protected boolean act() {
-
-			if (Dungeon.level.mobCount() < Dungeon.level.mobLimit()) {
-
-				if (Dungeon.level.spawnMob(12)){
-					spend(Dungeon.level.respawnCooldown());
-				} else {
-					//try again in 1 turn
-					spend(TICK);
-				}
-
-			} else {
-				spend(Dungeon.level.respawnCooldown());
-			}
-
-			return true;
-		}
-
-		protected void resetCooldown(){
-			spend(-cooldown());
-			spend(Dungeon.level.respawnCooldown());
-		}
-	}
-
-	public float respawnCooldown(){
-		if (Statistics.amuletObtained){
-			if (Dungeon.depth == 1){
-				//very fast spawns on floor 1! 0/2/4/6/8/10/12, etc.
-				return (Dungeon.level.mobCount()) * (TIME_TO_RESPAWN / 25f);
-			} else {
-				//respawn time is 5/5/10/15/20/25/25, etc.
-				return Math.round(GameMath.gate( TIME_TO_RESPAWN/10f, Dungeon.level.mobCount() * (TIME_TO_RESPAWN / 10f), TIME_TO_RESPAWN / 2f));
-			}
-		} else if (Dungeon.level.feeling == Feeling.DARK){
-			return 2*TIME_TO_RESPAWN/3f;
-		} else {
-			return TIME_TO_RESPAWN;
-		}
-	}
-
-	public boolean spawnMob(int disLimit){
-		PathFinder.buildDistanceMap(Dungeon.hero.pos, BArray.or(passable, avoid, null));
-
-		Mob mob = createMob();
-		mob.state = mob.WANDERING;
-		int tries = 30;
-		do {
-			mob.pos = randomRespawnCell(mob);
-			tries--;
-		} while ((mob.pos == -1 || PathFinder.distance[mob.pos] < disLimit) && tries > 0);
-
-		if (Dungeon.hero.isAlive() && mob.pos != -1 && PathFinder.distance[mob.pos] >= disLimit) {
-			GameScene.add( mob );
-			if (!mob.buffs(ChampionEnemy.class).isEmpty()){
-				GLog.w(Messages.get(ChampionEnemy.class, "warn"));
-			}
-			return true;
-		} else {
-			return false;
-		}
-	}
-	
-	public int randomRespawnCell( Char ch ) {
-		int cell;
-		int count = 0;
-		do {
-
-			if (++count > 30) {
-				return -1;
-			}
-
-			cell = Random.Int( length() );
-
-		} while ((Dungeon.level == this && heroFOV[cell])
-				|| !passable[cell]
-				|| (Char.hasProp(ch, Char.Property.LARGE) && !openSpace[cell])
-				|| Actor.findChar( cell ) != null);
-		return cell;
-	}
-	
-	public int randomDestination( Char ch ) {
-		int cell;
-		do {
-			cell = Random.Int( length() );
-		} while (!passable[cell]
-				|| (Char.hasProp(ch, Char.Property.LARGE) && !openSpace[cell]));
-		return cell;
-	}
-	
-	public void addItemToSpawn( Item item ) {
-		if (item != null) {
-			itemsToSpawn.add( item );
-		}
-	}
-
-	public Item findPrizeItem(){ return findPrizeItem(null); }
-
-	public Item findPrizeItem(Class<?extends Item> match){
-		if (itemsToSpawn.size() == 0)
-			return null;
-
-		if (match == null){
-			Item item = Random.element(itemsToSpawn);
-			itemsToSpawn.remove(item);
-			return item;
-		}
-
-		for (Item item : itemsToSpawn){
-			if (match.isInstance(item)){
-				itemsToSpawn.remove( item );
-				return item;
-			}
-		}
-
-		return null;
-	}
-
-	public void buildFlagMaps() {
-		
-		for (int i=0; i < length(); i++) {
-			int flags = Terrain.flags[map[i]];
-			passable[i]		= (flags & Terrain.PASSABLE) != 0;
-			losBlocking[i]	= (flags & Terrain.LOS_BLOCKING) != 0;
-			flamable[i]		= (flags & Terrain.FLAMABLE) != 0;
-			secret[i]		= (flags & Terrain.SECRET) != 0;
-			solid[i]		= (flags & Terrain.SOLID) != 0;
-			avoid[i]		= (flags & Terrain.AVOID) != 0;
-			water[i]		= (flags & Terrain.LIQUID) != 0;
-			pit[i]			= (flags & Terrain.PIT) != 0;
-		}
-
-		for (Blob b : blobs.values()){
-			b.onBuildFlagMaps(this);
-		}
-		
-		int lastRow = length() - width();
-		for (int i=0; i < width(); i++) {
-			passable[i] = avoid[i] = false;
-			losBlocking[i] = solid[i] = true;
-			passable[lastRow + i] = avoid[lastRow + i] = false;
-			losBlocking[lastRow + i] = solid[lastRow + i] = true;
-		}
-		for (int i=width(); i < lastRow; i += width()) {
-			passable[i] = avoid[i] = false;
-			losBlocking[i] = solid[i] = true;
-			passable[i + width()-1] = avoid[i + width()-1] = false;
-			losBlocking[i + width()-1] = solid[i + width()-1] = true;
-		}
-
-		//an open space is large enough to fit large mobs. A space is open when it is not solid
-		// and there is an open corner with both adjacent cells opens
-		for (int i=0; i < length(); i++) {
-			if (solid[i]){
-				openSpace[i] = false;
-			} else {
-				for (int j = 1; j < PathFinder.CIRCLE8.length; j += 2){
-					if (solid[i+PathFinder.CIRCLE8[j]]) {
-						openSpace[i] = false;
-					} else if (!solid[i+PathFinder.CIRCLE8[(j+1)%8]]
-							&& !solid[i+PathFinder.CIRCLE8[(j+2)%8]]){
-						openSpace[i] = true;
-						break;
-					}
-				}
-			}
-		}
-
-	}
-
-	public void destroy( int pos ) {
-		//if raw tile type is flammable or empty
-		int terr = map[pos];
-		if (terr == Terrain.EMPTY || terr == Terrain.EMPTY_DECO
-				|| (Terrain.flags[map[pos]] & Terrain.FLAMABLE) != 0) {
-			set(pos, Terrain.EMBERS);
-		}
-		Blob web = blobs.get(Web.class);
-		if (web != null){
-			web.clear(pos);
-		}
-	}
-
-	public void cleanWalls() {
-		if (discoverable == null || discoverable.length != length) {
-			discoverable = new boolean[length()];
-		}
-
-		for (int i=0; i < length(); i++) {
-			
-			boolean d = false;
-			
-			for (int j=0; j < PathFinder.NEIGHBOURS9.length; j++) {
-				int n = i + PathFinder.NEIGHBOURS9[j];
-				if (n >= 0 && n < length() && map[n] != Terrain.WALL && map[n] != Terrain.WALL_DECO) {
-					d = true;
-					break;
-				}
-			}
-			
-			discoverable[i] = d;
-		}
-	}
-	
-	public static void set( int cell, int terrain ){
-		set( cell, terrain, Dungeon.level );
-	}
-	
-	public static void set( int cell, int terrain, Level level ) {
-		Painter.set( level, cell, terrain );
-
-		if (terrain != Terrain.TRAP && terrain != Terrain.SECRET_TRAP && terrain != Terrain.INACTIVE_TRAP){
-			level.traps.remove( cell );
-		}
-
-		int flags = Terrain.flags[terrain];
-		level.passable[cell]		= (flags & Terrain.PASSABLE) != 0;
-		level.losBlocking[cell]	    = (flags & Terrain.LOS_BLOCKING) != 0;
-		level.flamable[cell]		= (flags & Terrain.FLAMABLE) != 0;
-		level.secret[cell]		    = (flags & Terrain.SECRET) != 0;
-		level.solid[cell]			= (flags & Terrain.SOLID) != 0;
-		level.avoid[cell]			= (flags & Terrain.AVOID) != 0;
-		level.pit[cell]			    = (flags & Terrain.PIT) != 0;
-		level.water[cell]			= terrain == Terrain.WATER;
-
-		for (int i : PathFinder.NEIGHBOURS9){
-			i = cell + i;
-			if (level.solid[i]){
-				level.openSpace[i] = false;
-			} else {
-				for (int j = 1; j < PathFinder.CIRCLE8.length; j += 2){
-					if (level.solid[i+PathFinder.CIRCLE8[j]]) {
-						level.openSpace[i] = false;
-					} else if (!level.solid[i+PathFinder.CIRCLE8[(j+1)%8]]
-							&& !level.solid[i+PathFinder.CIRCLE8[(j+2)%8]]){
-						level.openSpace[i] = true;
-						break;
-					}
-				}
-			}
-		}
-	}
-	
-	public Heap drop( Item item, int cell ) {
-
-		if (item == null || Challenges.isItemBlocked(item)){
-
-			//create a dummy heap, give it a dummy sprite, don't add it to the game, and return it.
-			//effectively nullifies whatever the logic calling this wants to do, including dropping items.
-			Heap heap = new Heap();
-			ItemSprite sprite = heap.sprite = new ItemSprite();
-			sprite.link(heap);
-			return heap;
-
-		}
-		
-		Heap heap = heaps.get( cell );
-		if (heap == null) {
-			
-			heap = new Heap();
-			heap.seen = Dungeon.level == this && heroFOV[cell];
-			heap.pos = cell;
-			heap.drop(item);
-			if (map[cell] == Terrain.CHASM || (Dungeon.level != null && pit[cell])) {
-				Dungeon.dropToChasm( item );
-				GameScene.discard( heap );
-			} else {
-				heaps.put( cell, heap );
-				GameScene.add( heap );
-			}
-			
-		} else if (heap.type == Heap.Type.LOCKED_CHEST || heap.type == Heap.Type.CRYSTAL_CHEST) {
-			
-			int n;
-			do {
-				n = cell + PathFinder.NEIGHBOURS8[Random.Int( 8 )];
-			} while (!passable[n] && !avoid[n]);
-			return drop( item, n );
-			
-		} else {
-			heap.drop(item);
-		}
-		
-		if (Dungeon.level != null && ShatteredPixelDungeon.scene() instanceof GameScene) {
-			pressCell( cell );
-		}
-		
-		return heap;
-	}
-	
-	public Plant plant( Plant.Seed seed, int pos ) {
-		
-		if (Dungeon.isChallenged(Challenges.NO_HERBALISM)){
-			return null;
-		}
-
-		Plant plant = plants.get( pos );
-		if (plant != null) {
-			plant.wither();
-		}
-
-		if (map[pos] == Terrain.HIGH_GRASS ||
-				map[pos] == Terrain.FURROWED_GRASS ||
-				map[pos] == Terrain.EMPTY ||
-				map[pos] == Terrain.EMBERS ||
-				map[pos] == Terrain.EMPTY_DECO) {
-			set(pos, Terrain.GRASS, this);
-			GameScene.updateMap(pos);
-		}
-		
-		plant = seed.couch( pos, this );
-		plants.put( pos, plant );
-		
-		GameScene.plantSeed( pos );
-
-		for (Char ch : Actor.chars()){
-			if (ch instanceof WandOfRegrowth.Lotus
-					&& ((WandOfRegrowth.Lotus) ch).inRange(pos)
-					&& Actor.findChar(pos) != null){
-				plant.trigger();
-				return null;
-			}
-		}
-		
-		return plant;
-	}
-	
-	public void uproot( int pos ) {
-		plants.remove(pos);
-		GameScene.updateMap( pos );
-	}
-
-	public Trap setTrap( Trap trap, int pos ){
-		Trap existingTrap = traps.get(pos);
-		if (existingTrap != null){
-			traps.remove( pos );
-		}
-		trap.set( pos );
-		traps.put( pos, trap );
-		GameScene.updateMap( pos );
-		return trap;
-	}
-
-	public void disarmTrap( int pos ) {
-		set(pos, Terrain.INACTIVE_TRAP);
-		GameScene.updateMap(pos);
-	}
-
-	public void discover( int cell ) {
-		set( cell, Terrain.discover( map[cell] ) );
-		Trap trap = traps.get( cell );
-		if (trap != null)
-			trap.reveal();
-		GameScene.updateMap( cell );
-	}
-
-	public boolean setCellToWater( boolean includeTraps, int cell ){
-		Point p = cellToPoint(cell);
-
-		//if a custom tilemap is over that cell, don't put water there
-		for (CustomTilemap cust : customTiles){
-			Point custPoint = new Point(p);
-			custPoint.x -= cust.tileX;
-			custPoint.y -= cust.tileY;
-			if (custPoint.x >= 0 && custPoint.y >= 0
-					&& custPoint.x < cust.tileW && custPoint.y < cust.tileH){
-				if (cust.image(custPoint.x, custPoint.y) != null){
-					return false;
-				}
-			}
-		}
-
-		int terr = map[cell];
-		if (terr == Terrain.EMPTY || terr == Terrain.GRASS ||
-				terr == Terrain.EMBERS || terr == Terrain.EMPTY_SP ||
-				terr == Terrain.HIGH_GRASS || terr == Terrain.FURROWED_GRASS
-				|| terr == Terrain.EMPTY_DECO){
-			set(cell, Terrain.WATER);
-			GameScene.updateMap(cell);
-			return true;
-		} else if (includeTraps && (terr == Terrain.SECRET_TRAP ||
-				terr == Terrain.TRAP || terr == Terrain.INACTIVE_TRAP)){
-			set(cell, Terrain.WATER);
-			Dungeon.level.traps.remove(cell);
-			GameScene.updateMap(cell);
-			return true;
-		}
-
-		return false;
-	}
-	
-	public int fallCell( boolean fallIntoPit ) {
-		int result;
-		do {
-			result = randomRespawnCell( null );
-			if (result == -1) return -1;
-		} while (traps.get(result) != null
-				|| findMob(result) != null);
-		return result;
-	}
-	
-	public void occupyCell( Char ch ){
-		if (!ch.isImmune(Web.class) && Blob.volumeAt(ch.pos, Web.class) > 0){
-			blobs.get(Web.class).clear(ch.pos);
-			Web.affectChar( ch );
-		}
-
-		if (!ch.flying){
-
-			if ( (map[ch.pos] == Terrain.GRASS || map[ch.pos] == Terrain.EMBERS)
-					&& ch == Dungeon.hero && Dungeon.hero.hasTalent(Talent.REJUVENATING_STEPS)
-					&& ch.buff(Talent.RejuvenatingStepsCooldown.class) == null){
-
-				if (Dungeon.hero.buff(LockedFloor.class) != null && !Dungeon.hero.buff(LockedFloor.class).regenOn()){
-					set(ch.pos, Terrain.FURROWED_GRASS);
-				} else if (ch.buff(Talent.RejuvenatingStepsFurrow.class) != null && ch.buff(Talent.RejuvenatingStepsFurrow.class).count() >= 200) {
-					set(ch.pos, Terrain.FURROWED_GRASS);
-				} else {
-					set(ch.pos, Terrain.HIGH_GRASS);
-					Buff.count(ch, Talent.RejuvenatingStepsFurrow.class, 3 - Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));
-				}
-				GameScene.updateMap(ch.pos);
-				Buff.affect(ch, Talent.RejuvenatingStepsCooldown.class, 15f - 5f*Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));
-			}
-			
-			if (pit[ch.pos]){
-				if (ch == Dungeon.hero) {
-					Chasm.heroFall(ch.pos);
-				} else if (ch instanceof Mob) {
-					Chasm.mobFall( (Mob)ch );
-				}
-				return;
-			}
-			
-			//characters which are not the hero or a sheep 'soft' press cells
-			pressCell( ch.pos, ch instanceof Hero || ch instanceof Sheep);
-		} else {
-			if (map[ch.pos] == Terrain.DOOR){
-				Door.enter( ch.pos );
-			}
-		}
-
-		if (ch.isAlive() && ch instanceof Piranha && !water[ch.pos]){
-			ch.die(null);
-		}
-	}
-	
-	//public method for forcing the hard press of a cell. e.g. when an item lands on it
-	public void pressCell( int cell ){
-		pressCell( cell, true );
-	}
-	
-	//a 'soft' press ignores hidden traps
-	//a 'hard' press triggers all things
-	private void pressCell( int cell, boolean hard ) {
-
-		Trap trap = null;
-		
-		switch (map[cell]) {
-		
-		case Terrain.SECRET_TRAP:
-			if (hard) {
-				trap = traps.get( cell );
-				GLog.i(Messages.get(Level.class, "hidden_trap", trap.name()));
-			}
-			break;
-			
-		case Terrain.TRAP:
-			trap = traps.get( cell );
-			break;
-			
-		case Terrain.HIGH_GRASS:
-		case Terrain.FURROWED_GRASS:
-			HighGrass.trample( this, cell);
-			break;
-			
-		case Terrain.WELL:
-			WellWater.affectCell( cell );
-			break;
-			
-		case Terrain.DOOR:
-			Door.enter( cell );
-			break;
-		}
-
-		TimekeepersHourglass.timeFreeze timeFreeze =
-				Dungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);
-
-		Swiftthistle.TimeBubble bubble =
-				Dungeon.hero.buff(Swiftthistle.TimeBubble.class);
-
-		if (trap != null) {
-			if (bubble != null){
-				Sample.INSTANCE.play(Assets.Sounds.TRAP);
-				discover(cell);
-				bubble.setDelayedPress(cell);
-				
-			} else if (timeFreeze != null){
-				Sample.INSTANCE.play(Assets.Sounds.TRAP);
-				discover(cell);
-				timeFreeze.setDelayedPress(cell);
-				
-			} else {
-				if (Dungeon.hero.pos == cell) {
-					Dungeon.hero.interrupt();
-				}
-				trap.trigger();
-
-			}
-		}
-		
-		Plant plant = plants.get( cell );
-		if (plant != null) {
-			if (bubble != null){
-				Sample.INSTANCE.play(Assets.Sounds.TRAMPLE, 1, Random.Float( 0.96f, 1.05f ) );
-				bubble.setDelayedPress(cell);
-
-			} else if (timeFreeze != null){
-				Sample.INSTANCE.play(Assets.Sounds.TRAMPLE, 1, Random.Float( 0.96f, 1.05f ) );
-				timeFreeze.setDelayedPress(cell);
-
-			} else {
-				plant.trigger();
-
-			}
-		}
-
-		if (hard && Blob.volumeAt(cell, Web.class) > 0){
-			blobs.get(Web.class).clear(cell);
-		}
-	}
-
-	private static boolean[] heroMindFov;
-
-	private static boolean[] modifiableBlocking;
-
-	public void updateFieldOfView( Char c, boolean[] fieldOfView ) {
-
-		int cx = c.pos % width();
-		int cy = c.pos / width();
-		
-		boolean sighted = c.buff( Blindness.class ) == null && c.buff( Shadows.class ) == null
-						&& c.buff( TimekeepersHourglass.timeStasis.class ) == null && c.isAlive();
-		if (sighted) {
-			boolean[] blocking = null;
-
-			if (modifiableBlocking == null || modifiableBlocking.length != Dungeon.level.losBlocking.length){
-				modifiableBlocking = new boolean[Dungeon.level.losBlocking.length];
-			}
-			
-			if ((c instanceof Hero && ((Hero) c).subClass == HeroSubClass.WARDEN)
-				|| c instanceof YogFist.SoiledFist) {
-				if (blocking == null) {
-					System.arraycopy(Dungeon.level.losBlocking, 0, modifiableBlocking, 0, modifiableBlocking.length);
-					blocking = modifiableBlocking;
-				}
-				for (int i = 0; i < blocking.length; i++){
-					if (blocking[i] && (Dungeon.level.map[i] == Terrain.HIGH_GRASS || Dungeon.level.map[i] == Terrain.FURROWED_GRASS)){
-						blocking[i] = false;
-					}
-				}
-			}
-
-			if (c.alignment != Char.Alignment.ALLY
-					&& Dungeon.level.blobs.containsKey(SmokeScreen.class)
-					&& Dungeon.level.blobs.get(SmokeScreen.class).volume > 0) {
-				if (blocking == null) {
-					System.arraycopy(Dungeon.level.losBlocking, 0, modifiableBlocking, 0, modifiableBlocking.length);
-					blocking = modifiableBlocking;
-				}
-				Blob s = Dungeon.level.blobs.get(SmokeScreen.class);
-				for (int i = 0; i < blocking.length; i++){
-					if (!blocking[i] && s.cur[i] > 0){
-						blocking[i] = true;
-					}
-				}
-			}
-
-			if (blocking == null){
-				blocking = Dungeon.level.losBlocking;
-			}
-			
-			int viewDist = c.viewDistance;
-			if (c instanceof Hero){
-				viewDist *= 1f + 0.25f*((Hero) c).pointsInTalent(Talent.FARSIGHT);
-			}
-			
-			ShadowCaster.castShadow( cx, cy, fieldOfView, blocking, viewDist );
-		} else {
-			BArray.setFalse(fieldOfView);
-		}
-		
-		int sense = 1;
-		//Currently only the hero can get mind vision
-		if (c.isAlive() && c == Dungeon.hero) {
-			for (Buff b : c.buffs( MindVision.class )) {
-				sense = Math.max( ((MindVision)b).distance, sense );
-			}
-			if (c.buff(MagicalSight.class) != null){
-				sense = Math.max( MagicalSight.DISTANCE, sense );
-			}
-		}
-		
-		//uses rounding
-		if (!sighted || sense > 1) {
-			
-			int[][] rounding = ShadowCaster.rounding;
-			
-			int left, right;
-			int pos;
-			for (int y = Math.max(0, cy - sense); y <= Math.min(height()-1, cy + sense); y++) {
-				if (rounding[sense][Math.abs(cy - y)] < Math.abs(cy - y)) {
-					left = cx - rounding[sense][Math.abs(cy - y)];
-				} else {
-					left = sense;
-					while (rounding[sense][left] < rounding[sense][Math.abs(cy - y)]){
-						left--;
-					}
-					left = cx - left;
-				}
-				right = Math.min(width()-1, cx + cx - left);
-				left = Math.max(0, left);
-				pos = left + y * width();
-				System.arraycopy(discoverable, pos, fieldOfView, pos, right - left + 1);
-			}
-		}
-
-		if (c instanceof SpiritHawk.HawkAlly && Dungeon.hero.pointsInTalent(Talent.EAGLE_EYE) >= 3){
-			int range = 1+(Dungeon.hero.pointsInTalent(Talent.EAGLE_EYE)-2);
-			for (Mob mob : mobs) {
-				int p = mob.pos;
-				if (!fieldOfView[p] && distance(c.pos, p) <= range) {
-					for (int i : PathFinder.NEIGHBOURS9) {
-						fieldOfView[mob.pos + i] = true;
-					}
-				}
-			}
-		}
-
-		//Currently only the hero can get mind vision or awareness
-		if (c.isAlive() && c == Dungeon.hero) {
-
-			if (heroMindFov == null || heroMindFov.length != length()){
-				heroMindFov = new boolean[length];
-			} else {
-				BArray.setFalse(heroMindFov);
-			}
-
-			Dungeon.hero.mindVisionEnemies.clear();
-			if (c.buff( MindVision.class ) != null) {
-				for (Mob mob : mobs) {
-					for (int i : PathFinder.NEIGHBOURS9) {
-						heroMindFov[mob.pos + i] = true;
-					}
-				}
-			} else if (((Hero) c).hasTalent(Talent.HEIGHTENED_SENSES)) {
-				Hero h = (Hero) c;
-				int range = 1+h.pointsInTalent(Talent.HEIGHTENED_SENSES);
-				for (Mob mob : mobs) {
-					int p = mob.pos;
-					if (!fieldOfView[p] && distance(c.pos, p) <= range) {
-						for (int i : PathFinder.NEIGHBOURS9) {
-							heroMindFov[mob.pos + i] = true;
-						}
-					}
-				}
-			}
-			
-			if (c.buff( Awareness.class ) != null) {
-				for (Heap heap : heaps.valueList()) {
-					int p = heap.pos;
-					for (int i : PathFinder.NEIGHBOURS9) heroMindFov[p+i] = true;
-				}
-			}
-
-			for (TalismanOfForesight.CharAwareness a : c.buffs(TalismanOfForesight.CharAwareness.class)){
-				Char ch = (Char) Actor.findById(a.charID);
-				if (ch == null || !ch.isAlive()) {
-					continue;
-				}
-				int p = ch.pos;
-				for (int i : PathFinder.NEIGHBOURS9) heroMindFov[p+i] = true;
-			}
-
-			for (TalismanOfForesight.HeapAwareness h : c.buffs(TalismanOfForesight.HeapAwareness.class)){
-				if (Dungeon.depth != h.depth) continue;
-				for (int i : PathFinder.NEIGHBOURS9) heroMindFov[h.pos+i] = true;
-			}
-
-			for (Mob m : mobs){
-				if (m instanceof WandOfWarding.Ward
-						|| m instanceof WandOfRegrowth.Lotus
-						|| m instanceof SpiritHawk.HawkAlly){
-					if (m.fieldOfView == null || m.fieldOfView.length != length()){
-						m.fieldOfView = new boolean[length()];
-						Dungeon.level.updateFieldOfView( m, m.fieldOfView );
-					}
-					BArray.or(heroMindFov, m.fieldOfView, heroMindFov);
-				}
-			}
-
-			for (RevealedArea a : c.buffs(RevealedArea.class)){
-				if (Dungeon.depth != a.depth) continue;
-				for (int i : PathFinder.NEIGHBOURS9) heroMindFov[a.pos+i] = true;
-			}
-
-			//set mind vision chars
-			for (Mob mob : mobs) {
-				if (heroMindFov[mob.pos] && !fieldOfView[mob.pos]){
-					Dungeon.hero.mindVisionEnemies.add(mob);
-				}
-			}
-
-			BArray.or(heroMindFov, fieldOfView, fieldOfView);
-
-		}
-
-		if (c == Dungeon.hero) {
-			for (Heap heap : heaps.valueList())
-				if (!heap.seen && fieldOfView[heap.pos])
-					heap.seen = true;
-		}
-
-	}
-
-	public boolean isLevelExplored( int depth ){
-		return false;
-	}
-	
-	public int distance( int a, int b ) {
-		int ax = a % width();
-		int ay = a / width();
-		int bx = b % width();
-		int by = b / width();
-		return Math.max( Math.abs( ax - bx ), Math.abs( ay - by ) );
-	}
-	
-	public boolean adjacent( int a, int b ) {
-		return distance( a, b ) == 1;
-	}
-	
-	//uses pythagorean theorum for true distance, as if there was no movement grid
-	public float trueDistance(int a, int b){
-		int ax = a % width();
-		int ay = a / width();
-		int bx = b % width();
-		int by = b / width();
-		return (float)Math.sqrt(Math.pow(Math.abs( ax - bx ), 2) + Math.pow(Math.abs( ay - by ), 2));
-	}
-
-	//returns true if the input is a valid tile within the level
-	public boolean insideMap( int tile ){
-				//top and bottom row and beyond
-		return !((tile < width || tile >= length - width) ||
-				//left and right column
-				(tile % width == 0 || tile % width == width-1));
-	}
-
-	public Point cellToPoint( int cell ){
-		return new Point(cell % width(), cell / width());
-	}
-
-	public int pointToCell( Point p ){
-		return p.x + p.y*width();
-	}
-	
-	public String tileName( int tile ) {
-		
-		switch (tile) {
-			case Terrain.CHASM:
-				return Messages.get(Level.class, "chasm_name");
-			case Terrain.EMPTY:
-			case Terrain.EMPTY_SP:
-			case Terrain.EMPTY_DECO:
-			case Terrain.SECRET_TRAP:
-				return Messages.get(Level.class, "floor_name");
-			case Terrain.GRASS:
-				return Messages.get(Level.class, "grass_name");
-			case Terrain.WATER:
-				return Messages.get(Level.class, "water_name");
-			case Terrain.WALL:
-			case Terrain.WALL_DECO:
-			case Terrain.SECRET_DOOR:
-				return Messages.get(Level.class, "wall_name");
-			case Terrain.DOOR:
-				return Messages.get(Level.class, "closed_door_name");
-			case Terrain.OPEN_DOOR:
-				return Messages.get(Level.class, "open_door_name");
-			case Terrain.ENTRANCE:
-				return Messages.get(Level.class, "entrace_name");
-			case Terrain.EXIT:
-				return Messages.get(Level.class, "exit_name");
-			case Terrain.EMBERS:
-				return Messages.get(Level.class, "embers_name");
-			case Terrain.FURROWED_GRASS:
-				return Messages.get(Level.class, "furrowed_grass_name");
-			case Terrain.LOCKED_DOOR:
-				return Messages.get(Level.class, "locked_door_name");
-			case Terrain.CRYSTAL_DOOR:
-				return Messages.get(Level.class, "crystal_door_name");
-			case Terrain.PEDESTAL:
-				return Messages.get(Level.class, "pedestal_name");
-			case Terrain.BARRICADE:
-				return Messages.get(Level.class, "barricade_name");
-			case Terrain.HIGH_GRASS:
-				return Messages.get(Level.class, "high_grass_name");
-			case Terrain.LOCKED_EXIT:
-				return Messages.get(Level.class, "locked_exit_name");
-			case Terrain.UNLOCKED_EXIT:
-				return Messages.get(Level.class, "unlocked_exit_name");
-			case Terrain.SIGN:
-				return Messages.get(Level.class, "sign_name");
-			case Terrain.WELL:
-				return Messages.get(Level.class, "well_name");
-			case Terrain.EMPTY_WELL:
-				return Messages.get(Level.class, "empty_well_name");
-			case Terrain.STATUE:
-			case Terrain.STATUE_SP:
-				return Messages.get(Level.class, "statue_name");
-			case Terrain.INACTIVE_TRAP:
-				return Messages.get(Level.class, "inactive_trap_name");
-			case Terrain.BOOKSHELF:
-				return Messages.get(Level.class, "bookshelf_name");
-			case Terrain.ALCHEMY:
-				return Messages.get(Level.class, "alchemy_name");
-			default:
-				return Messages.get(Level.class, "default_name");
-		}
-	}
-	
-	public String tileDesc( int tile ) {
-		
-		switch (tile) {
-			case Terrain.CHASM:
-				return Messages.get(Level.class, "chasm_desc");
-			case Terrain.WATER:
-				return Messages.get(Level.class, "water_desc");
-			case Terrain.ENTRANCE:
-				return Messages.get(Level.class, "entrance_desc");
-			case Terrain.EXIT:
-			case Terrain.UNLOCKED_EXIT:
-				return Messages.get(Level.class, "exit_desc");
-			case Terrain.EMBERS:
-				return Messages.get(Level.class, "embers_desc");
-			case Terrain.HIGH_GRASS:
-			case Terrain.FURROWED_GRASS:
-				return Messages.get(Level.class, "high_grass_desc");
-			case Terrain.LOCKED_DOOR:
-				return Messages.get(Level.class, "locked_door_desc");
-			case Terrain.CRYSTAL_DOOR:
-				return Messages.get(Level.class, "crystal_door_desc");
-			case Terrain.LOCKED_EXIT:
-				return Messages.get(Level.class, "locked_exit_desc");
-			case Terrain.BARRICADE:
-				return Messages.get(Level.class, "barricade_desc");
-			case Terrain.SIGN:
-				return Messages.get(Level.class, "sign_desc");
-			case Terrain.INACTIVE_TRAP:
-				return Messages.get(Level.class, "inactive_trap_desc");
-			case Terrain.STATUE:
-			case Terrain.STATUE_SP:
-				return Messages.get(Level.class, "statue_desc");
-			case Terrain.ALCHEMY:
-				return Messages.get(Level.class, "alchemy_desc");
-			case Terrain.EMPTY_WELL:
-				return Messages.get(Level.class, "empty_well_desc");
-			default:
-				return "";
-		}
-	}
+
+    public static enum Feeling {
+        NONE,
+        CHASM,
+        WATER,
+        GRASS,
+        DARK,
+        LARGE,
+        TRAPS,
+        SECRETS
+    }
+
+    protected int width;
+    protected int height;
+    protected int length;
+
+    protected static final float TIME_TO_RESPAWN = 50;
+
+    public int version;
+
+    public int[] map;
+    public boolean[] visited;
+    public boolean[] mapped;
+    public boolean[] discoverable;
+
+    public int viewDistance = Dungeon.isChallenged(Challenges.DARKNESS) ? 2 : 8;
+
+    public boolean[] heroFOV;
+
+    public boolean[] passable;
+    public boolean[] losBlocking;
+    public boolean[] flamable;
+    public boolean[] secret;
+    public boolean[] solid;
+    public boolean[] avoid;
+    public boolean[] water;
+    public boolean[] pit;
+
+    public boolean[] openSpace;
+
+    public Feeling feeling = Feeling.NONE;
+
+    public int entrance;
+    public int exit;
+
+    public ArrayList<LevelTransition> transitions;
+
+    //when a boss level has become locked.
+    public boolean locked = false;
+
+    public HashSet<Mob> mobs;
+    public SparseArray<Heap> heaps;
+    public HashMap<Class<? extends Blob>, Blob> blobs;
+    public SparseArray<Plant> plants;
+    public SparseArray<Trap> traps;
+    public HashSet<CustomTilemap> customTiles;
+    public HashSet<CustomTilemap> customWalls;
+
+    protected ArrayList<Item> itemsToSpawn = new ArrayList<>();
+
+    protected Group visuals;
+
+    public int color1 = 0x004400;
+    public int color2 = 0x88CC44;
+
+    private static final String VERSION = "version";
+    private static final String WIDTH = "width";
+    private static final String HEIGHT = "height";
+    private static final String MAP = "map";
+    private static final String VISITED = "visited";
+    private static final String MAPPED = "mapped";
+    private static final String TRANSITIONS = "transitions";
+    private static final String LOCKED = "locked";
+    private static final String HEAPS = "heaps";
+    private static final String PLANTS = "plants";
+    private static final String TRAPS = "traps";
+    private static final String CUSTOM_TILES = "customTiles";
+    private static final String CUSTOM_WALLS = "customWalls";
+    private static final String MOBS = "mobs";
+    private static final String BLOBS = "blobs";
+    private static final String FEELING = "feeling";
+
+    public void create() {
+
+        Random.pushGenerator(Dungeon.seedCurDepth());
+
+        if (!(Dungeon.bossLevel())) {
+
+            addItemToSpawn(Generator.random(Generator.Category.FOOD));
+
+            if (Dungeon.isChallenged(Challenges.DARKNESS)) {
+                addItemToSpawn(new Torch());
+            }
+
+            if (Dungeon.posNeeded()) {
+                addItemToSpawn(new PotionOfStrength());
+                Dungeon.LimitedDrops.STRENGTH_POTIONS.count++;
+            }
+            if (Dungeon.souNeeded()) {
+                addItemToSpawn(new ScrollOfUpgrade());
+                Dungeon.LimitedDrops.UPGRADE_SCROLLS.count++;
+            }
+            if (Dungeon.asNeeded()) {
+                addItemToSpawn(new Stylus());
+                Dungeon.LimitedDrops.ARCANE_STYLI.count++;
+            }
+            //one scroll of transmutation is guaranteed to spawn somewhere on chapter 2-4
+            int enchChapter = (int) ((Dungeon.seed / 10) % 3) + 1;
+            if (Dungeon.depth / 5 == enchChapter &&
+                    Dungeon.seed % 4 + 1 == Dungeon.depth % 5) {
+                addItemToSpawn(new StoneOfEnchantment());
+            }
+
+            if (Dungeon.depth == ((Dungeon.seed % 3) + 1)) {
+                addItemToSpawn(new StoneOfIntuition());
+            }
+
+//			if (Dungeon.depth > 1) {
+//				//50% chance of getting a level feeling
+//				//~7.15% chance for each feeling
+//				switch (Random.Int( 14 )) {
+//					case 0:
+//						feeling = Feeling.CHASM;
+//						break;
+//					case 1:
+//						feeling = Feeling.WATER;
+//						break;
+//					case 2:
+//						feeling = Feeling.GRASS;
+//						break;
+//					case 3:
+//						feeling = Feeling.DARK;
+//						addItemToSpawn(new Torch());
+//						viewDistance = Math.round(viewDistance/2f);
+//						break;
+//					case 4:
+//						feeling = Feeling.LARGE;
+//						addItemToSpawn(Generator.random(Generator.Category.FOOD));
+//						//add a second torch to help with the larger floor
+//						if (Dungeon.isChallenged(Challenges.DARKNESS)){
+//							addItemToSpawn( new Torch() );
+//						}
+//						break;
+//					case 5:
+//						feeling = Feeling.TRAPS;
+//						break;
+//					case 6:
+//						feeling = Feeling.SECRETS;
+//						break;
+//				}
+//			}
+        }
+
+        do {
+            width = height = length = 0;
+
+            transitions = new ArrayList<>();
+
+            mobs = new HashSet<>();
+            heaps = new SparseArray<>();
+            blobs = new HashMap<>();
+            plants = new SparseArray<>();
+            traps = new SparseArray<>();
+            customTiles = new HashSet<>();
+            customWalls = new HashSet<>();
+
+        } while (!build());
+
+        buildFlagMaps();
+        cleanWalls();
+
+        createMobs();
+        createItems();
+
+        Random.popGenerator();
+    }
+
+    public void setSize(int w, int h) {
+
+        width = w;
+        height = h;
+        length = w * h;
+
+        map = new int[length];
+        Arrays.fill(map, feeling == Level.Feeling.CHASM ? Terrain.CHASM : Terrain.WALL);
+
+        visited = new boolean[length];
+        mapped = new boolean[length];
+
+        heroFOV = new boolean[length];
+
+        passable = new boolean[length];
+        losBlocking = new boolean[length];
+        flamable = new boolean[length];
+        secret = new boolean[length];
+        solid = new boolean[length];
+        avoid = new boolean[length];
+        water = new boolean[length];
+        pit = new boolean[length];
+
+        openSpace = new boolean[length];
+
+        PathFinder.setMapSize(w, h);
+    }
+
+    public void reset() {
+
+        for (Mob mob : mobs.toArray(new Mob[0])) {
+            if (!mob.reset()) {
+                mobs.remove(mob);
+            }
+        }
+        createMobs();
+    }
+
+    public void playLevelMusic() {
+        //do nothing by default
+    }
+
+    @Override
+    public void restoreFromBundle(Bundle bundle) {
+
+        version = bundle.getInt(VERSION);
+
+        //saves from before v1.2.3 are not supported
+        if (version < ShatteredPixelDungeon.v1_2_3) {
+            throw new RuntimeException("old save");
+        }
+
+        setSize(bundle.getInt(WIDTH), bundle.getInt(HEIGHT));
+
+        mobs = new HashSet<>();
+        heaps = new SparseArray<>();
+        blobs = new HashMap<>();
+        plants = new SparseArray<>();
+        traps = new SparseArray<>();
+        customTiles = new HashSet<>();
+        customWalls = new HashSet<>();
+
+        map = bundle.getIntArray(MAP);
+
+        visited = bundle.getBooleanArray(VISITED);
+        mapped = bundle.getBooleanArray(MAPPED);
+
+        transitions = new ArrayList<>();
+        if (bundle.contains(TRANSITIONS)) {
+            for (Bundlable b : bundle.getCollection(TRANSITIONS)) {
+                transitions.add((LevelTransition) b);
+            }
+            //pre-1.3.0 saves, converts old entrance/exit to new transitions
+        } else {
+            if (bundle.contains("entrance")) {
+                transitions.add(new LevelTransition(
+                        this,
+                        bundle.getInt("entrance"),
+                        Dungeon.depth == 1 ? LevelTransition.Type.SURFACE : LevelTransition.Type.REGULAR_ENTRANCE));
+            }
+            if (bundle.contains("exit")) {
+                transitions.add(new LevelTransition(this, bundle.getInt("exit"), LevelTransition.Type.REGULAR_EXIT));
+            }
+        }
+
+        locked = bundle.getBoolean(LOCKED);
+
+        Collection<Bundlable> collection = bundle.getCollection(HEAPS);
+        for (Bundlable h : collection) {
+            Heap heap = (Heap) h;
+            if (!heap.isEmpty())
+                heaps.put(heap.pos, heap);
+        }
+
+        collection = bundle.getCollection(PLANTS);
+        for (Bundlable p : collection) {
+            Plant plant = (Plant) p;
+            plants.put(plant.pos, plant);
+        }
+
+        collection = bundle.getCollection(TRAPS);
+        for (Bundlable p : collection) {
+            Trap trap = (Trap) p;
+            traps.put(trap.pos, trap);
+        }
+
+        collection = bundle.getCollection(CUSTOM_TILES);
+        for (Bundlable p : collection) {
+            CustomTilemap vis = (CustomTilemap) p;
+            customTiles.add(vis);
+        }
+
+        collection = bundle.getCollection(CUSTOM_WALLS);
+        for (Bundlable p : collection) {
+            CustomTilemap vis = (CustomTilemap) p;
+            customWalls.add(vis);
+        }
+
+        collection = bundle.getCollection(MOBS);
+        for (Bundlable m : collection) {
+            Mob mob = (Mob) m;
+            if (mob != null) {
+                mobs.add(mob);
+            }
+        }
+
+        collection = bundle.getCollection(BLOBS);
+        for (Bundlable b : collection) {
+            Blob blob = (Blob) b;
+            blobs.put(blob.getClass(), blob);
+        }
+
+        feeling = bundle.getEnum(FEELING, Feeling.class);
+        if (feeling == Feeling.DARK)
+            viewDistance = Math.round(viewDistance / 2f);
+
+        if (bundle.contains("mobs_to_spawn")) {
+            for (Class<? extends Mob> mob : bundle.getClassArray("mobs_to_spawn")) {
+                if (mob != null) mobsToSpawn.add(mob);
+            }
+        }
+
+        if (bundle.contains("respawner")) {
+            respawner = (Respawner) bundle.get("respawner");
+        }
+
+        buildFlagMaps();
+        cleanWalls();
+
+    }
+
+    @Override
+    public void storeInBundle(Bundle bundle) {
+        bundle.put(VERSION, Game.versionCode);
+        bundle.put(WIDTH, width);
+        bundle.put(HEIGHT, height);
+        bundle.put(MAP, map);
+        bundle.put(VISITED, visited);
+        bundle.put(MAPPED, mapped);
+        bundle.put(TRANSITIONS, transitions);
+        bundle.put(LOCKED, locked);
+        bundle.put(HEAPS, heaps.valueList());
+        bundle.put(PLANTS, plants.valueList());
+        bundle.put(TRAPS, traps.valueList());
+        bundle.put(CUSTOM_TILES, customTiles);
+        bundle.put(CUSTOM_WALLS, customWalls);
+        bundle.put(MOBS, mobs);
+        bundle.put(BLOBS, blobs.values());
+        bundle.put(FEELING, feeling);
+        bundle.put("mobs_to_spawn", mobsToSpawn.toArray(new Class[0]));
+        bundle.put("respawner", respawner);
+    }
+
+    public int tunnelTile() {
+        return feeling == Feeling.CHASM ? Terrain.EMPTY_SP : Terrain.EMPTY;
+    }
+
+    public int width() {
+        return width;
+    }
+
+    public int height() {
+        return height;
+    }
+
+    public int length() {
+        return length;
+    }
+
+    public String tilesTex() {
+        return null;
+    }
+
+    public String waterTex() {
+        return null;
+    }
+
+    abstract protected boolean build();
+
+    private ArrayList<Class<? extends Mob>> mobsToSpawn = new ArrayList<>();
+
+    public Mob createMob() {
+        if (mobsToSpawn == null || mobsToSpawn.isEmpty()) {
+            mobsToSpawn = Bestiary.getMobRotation(Dungeon.depth);
+        }
+
+        Mob m = Reflection.newInstance(mobsToSpawn.remove(0));
+        ChampionEnemy.rollForChampion(m);
+        return m;
+    }
+
+    abstract protected void createMobs();
+
+    abstract protected void createItems();
+
+    public int entrance() {
+        LevelTransition l = getTransition(null);
+        if (l != null) {
+            return l.cell();
+        }
+        return 0;
+    }
+
+    public int exit() {
+        LevelTransition l = getTransition(LevelTransition.Type.REGULAR_EXIT);
+        if (l != null) {
+            return l.cell();
+        }
+        return 0;
+    }
+
+    public LevelTransition getTransition(LevelTransition.Type type) {
+        for (LevelTransition transition : transitions) {
+            //if we don't specify a type, prefer to return any entrance
+            if (type == null &&
+                    (transition.type == LevelTransition.Type.REGULAR_ENTRANCE || transition.type == LevelTransition.Type.SURFACE)) {
+                return transition;
+            } else if (transition.type == type) {
+                return transition;
+            }
+        }
+        return (type == null && !transitions.isEmpty() ? transitions.get(0) : null);
+    }
+
+    public LevelTransition getTransition(int cell) {
+        for (LevelTransition transition : transitions) {
+            if (transition.inside(cell)) {
+                return transition;
+            }
+        }
+        return null;
+    }
+
+    //some buff effects have special logic or are cancelled from the hero before transitioning levels
+    public static void beforeTransition() {
+
+        //time freeze effects need to resolve their pressed cells before transitioning
+        TimekeepersHourglass.timeFreeze timeFreeze = Dungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);
+        if (timeFreeze != null) timeFreeze.disarmPresses();
+        Swiftthistle.TimeBubble timeBubble = Dungeon.hero.buff(Swiftthistle.TimeBubble.class);
+        if (timeBubble != null) timeBubble.disarmPresses();
+
+        //iron stomach does not persist through chasm falling
+        Talent.WarriorFoodImmunity foodImmune = Dungeon.hero.buff(Talent.WarriorFoodImmunity.class);
+        if (foodImmune != null) foodImmune.detach();
+    }
+
+    public void seal() {
+        if (!locked) {
+            locked = true;
+            Buff.affect(Dungeon.hero, LockedFloor.class);
+        }
+    }
+
+    public void unseal() {
+        if (locked) {
+            locked = false;
+            if (Dungeon.hero.buff(LockedFloor.class) != null) {
+                Dungeon.hero.buff(LockedFloor.class).detach();
+            }
+        }
+    }
+
+    public ArrayList<Item> getItemsToPreserveFromSealedResurrect() {
+        ArrayList<Item> items = new ArrayList<>();
+        for (Heap h : heaps.valueList()) {
+            if (h.type == Heap.Type.HEAP) items.addAll(h.items);
+        }
+        for (Mob m : mobs) {
+            for (PinCushion b : m.buffs(PinCushion.class)) {
+                items.addAll(b.getStuckItems());
+            }
+        }
+        for (HeavyBoomerang.CircleBack b : Dungeon.hero.buffs(HeavyBoomerang.CircleBack.class)) {
+            if (b.activeDepth() == Dungeon.depth) items.add(b.cancel());
+        }
+        return items;
+    }
+
+    public Group addVisuals() {
+        if (visuals == null || visuals.parent == null) {
+            visuals = new Group();
+        } else {
+            visuals.clear();
+            visuals.camera = null;
+        }
+        for (int i = 0; i < length(); i++) {
+            if (pit[i]) {
+                visuals.add(new WindParticle.Wind(i));
+                if (i >= width() && water[i - width()]) {
+                    visuals.add(new FlowParticle.Flow(i - width()));
+                }
+            }
+        }
+        return visuals;
+    }
+
+    public int mobLimit() {
+        return 0;
+    }
+
+    public int mobCount() {
+        float count = 0;
+        for (Mob mob : Dungeon.level.mobs.toArray(new Mob[0])) {
+            if (mob.alignment == Char.Alignment.ENEMY && !mob.properties().contains(Char.Property.MINIBOSS)) {
+                count += mob.spawningWeight();
+            }
+        }
+        return Math.round(count);
+    }
+
+    public Mob findMob(int pos) {
+        for (Mob mob : mobs) {
+            if (mob.pos == pos) {
+                return mob;
+            }
+        }
+        return null;
+    }
+
+    private Respawner respawner;
+
+    public Actor addRespawner() {
+        if (respawner == null) {
+            respawner = new Respawner();
+            Actor.addDelayed(respawner, respawnCooldown());
+        } else {
+            Actor.add(respawner);
+            if (respawner.cooldown() > respawnCooldown()) {
+                respawner.resetCooldown();
+            }
+        }
+        return respawner;
+    }
+
+    public static class Respawner extends Actor {
+        {
+            actPriority = BUFF_PRIO; //as if it were a buff.
+        }
+
+        @Override
+        protected boolean act() {
+
+            if (Dungeon.level.mobCount() < Dungeon.level.mobLimit()) {
+
+                if (Dungeon.level.spawnMob(12)) {
+                    spend(Dungeon.level.respawnCooldown());
+                } else {
+                    //try again in 1 turn
+                    spend(TICK);
+                }
+
+            } else {
+                spend(Dungeon.level.respawnCooldown());
+            }
+
+            return true;
+        }
+
+        protected void resetCooldown() {
+            spend(-cooldown());
+            spend(Dungeon.level.respawnCooldown());
+        }
+    }
+
+    public float respawnCooldown() {
+        if (Statistics.amuletObtained) {
+            if (Dungeon.depth == 1) {
+                //very fast spawns on floor 1! 0/2/4/6/8/10/12, etc.
+                return (Dungeon.level.mobCount()) * (TIME_TO_RESPAWN / 25f);
+            } else {
+                //respawn time is 5/5/10/15/20/25/25, etc.
+                return Math.round(GameMath.gate(TIME_TO_RESPAWN / 10f, Dungeon.level.mobCount() * (TIME_TO_RESPAWN / 10f), TIME_TO_RESPAWN / 2f));
+            }
+        } else if (Dungeon.level.feeling == Feeling.DARK) {
+            return 2 * TIME_TO_RESPAWN / 3f;
+        } else {
+            return TIME_TO_RESPAWN;
+        }
+    }
+
+    public boolean spawnMob(int disLimit) {
+        PathFinder.buildDistanceMap(Dungeon.hero.pos, BArray.or(passable, avoid, null));
+
+        Mob mob = createMob();
+        mob.state = mob.WANDERING;
+        int tries = 30;
+        do {
+            mob.pos = randomRespawnCell(mob);
+            tries--;
+        } while ((mob.pos == -1 || PathFinder.distance[mob.pos] < disLimit) && tries > 0);
+
+        if (Dungeon.hero.isAlive() && mob.pos != -1 && PathFinder.distance[mob.pos] >= disLimit) {
+            GameScene.add(mob);
+            if (!mob.buffs(ChampionEnemy.class).isEmpty()) {
+                GLog.w(Messages.get(ChampionEnemy.class, "warn"));
+            }
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    public int randomRespawnCell(Char ch) {
+        int cell;
+        int count = 0;
+        do {
+
+            if (++count > 30) {
+                return -1;
+            }
+
+            cell = Random.Int(length());
+
+        } while ((Dungeon.level == this && heroFOV[cell])
+                || !passable[cell]
+                || (Char.hasProp(ch, Char.Property.LARGE) && !openSpace[cell])
+                || Actor.findChar(cell) != null);
+        return cell;
+    }
+
+    public int randomDestination(Char ch) {
+        int cell;
+        do {
+            cell = Random.Int(length());
+        } while (!passable[cell]
+                || (Char.hasProp(ch, Char.Property.LARGE) && !openSpace[cell]));
+        return cell;
+    }
+
+    public void addItemToSpawn(Item item) {
+        if (item != null) {
+            itemsToSpawn.add(item);
+        }
+    }
+
+    public Item findPrizeItem() {
+        return findPrizeItem(null);
+    }
+
+    public Item findPrizeItem(Class<? extends Item> match) {
+        if (itemsToSpawn.size() == 0)
+            return null;
+
+        if (match == null) {
+            Item item = Random.element(itemsToSpawn);
+            itemsToSpawn.remove(item);
+            return item;
+        }
+
+        for (Item item : itemsToSpawn) {
+            if (match.isInstance(item)) {
+                itemsToSpawn.remove(item);
+                return item;
+            }
+        }
+
+        return null;
+    }
+
+    public void buildFlagMaps() {
+
+        for (int i = 0; i < length(); i++) {
+            int flags = Terrain.flags[map[i]];
+            passable[i] = (flags & Terrain.PASSABLE) != 0;
+            losBlocking[i] = (flags & Terrain.LOS_BLOCKING) != 0;
+            flamable[i] = (flags & Terrain.FLAMABLE) != 0;
+            secret[i] = (flags & Terrain.SECRET) != 0;
+            solid[i] = (flags & Terrain.SOLID) != 0;
+            avoid[i] = (flags & Terrain.AVOID) != 0;
+            water[i] = (flags & Terrain.LIQUID) != 0;
+            pit[i] = (flags & Terrain.PIT) != 0;
+        }
+
+        for (Blob b : blobs.values()) {
+            b.onBuildFlagMaps(this);
+        }
+
+        int lastRow = length() - width();
+        for (int i = 0; i < width(); i++) {
+            passable[i] = avoid[i] = false;
+            losBlocking[i] = solid[i] = true;
+            passable[lastRow + i] = avoid[lastRow + i] = false;
+            losBlocking[lastRow + i] = solid[lastRow + i] = true;
+        }
+        for (int i = width(); i < lastRow; i += width()) {
+            passable[i] = avoid[i] = false;
+            losBlocking[i] = solid[i] = true;
+            passable[i + width() - 1] = avoid[i + width() - 1] = false;
+            losBlocking[i + width() - 1] = solid[i + width() - 1] = true;
+        }
+
+        //an open space is large enough to fit large mobs. A space is open when it is not solid
+        // and there is an open corner with both adjacent cells opens
+        for (int i = 0; i < length(); i++) {
+            if (solid[i]) {
+                openSpace[i] = false;
+            } else {
+                for (int j = 1; j < PathFinder.CIRCLE8.length; j += 2) {
+                    if (solid[i + PathFinder.CIRCLE8[j]]) {
+                        openSpace[i] = false;
+                    } else if (!solid[i + PathFinder.CIRCLE8[(j + 1) % 8]]
+                            && !solid[i + PathFinder.CIRCLE8[(j + 2) % 8]]) {
+                        openSpace[i] = true;
+                        break;
+                    }
+                }
+            }
+        }
+
+    }
+
+    public void destroy(int pos) {
+        //if raw tile type is flammable or empty
+        int terr = map[pos];
+        if (terr == Terrain.EMPTY || terr == Terrain.EMPTY_DECO
+                || (Terrain.flags[map[pos]] & Terrain.FLAMABLE) != 0) {
+            set(pos, Terrain.EMBERS);
+        }
+        Blob web = blobs.get(Web.class);
+        if (web != null) {
+            web.clear(pos);
+        }
+    }
+
+    public void cleanWalls() {
+        if (discoverable == null || discoverable.length != length) {
+            discoverable = new boolean[length()];
+        }
+
+        for (int i = 0; i < length(); i++) {
+
+            boolean d = false;
+
+            for (int j = 0; j < PathFinder.NEIGHBOURS9.length; j++) {
+                int n = i + PathFinder.NEIGHBOURS9[j];
+                if (n >= 0 && n < length() && map[n] != Terrain.WALL && map[n] != Terrain.WALL_DECO) {
+                    d = true;
+                    break;
+                }
+            }
+
+            discoverable[i] = d;
+        }
+    }
+
+    public static void set(int cell, int terrain) {
+        set(cell, terrain, Dungeon.level);
+    }
+
+    public static void set(int cell, int terrain, Level level) {
+        Painter.set(level, cell, terrain);
+
+        if (terrain != Terrain.TRAP && terrain != Terrain.SECRET_TRAP && terrain != Terrain.INACTIVE_TRAP) {
+            level.traps.remove(cell);
+        }
+
+        int flags = Terrain.flags[terrain];
+        level.passable[cell] = (flags & Terrain.PASSABLE) != 0;
+        level.losBlocking[cell] = (flags & Terrain.LOS_BLOCKING) != 0;
+        level.flamable[cell] = (flags & Terrain.FLAMABLE) != 0;
+        level.secret[cell] = (flags & Terrain.SECRET) != 0;
+        level.solid[cell] = (flags & Terrain.SOLID) != 0;
+        level.avoid[cell] = (flags & Terrain.AVOID) != 0;
+        level.pit[cell] = (flags & Terrain.PIT) != 0;
+        level.water[cell] = terrain == Terrain.WATER;
+
+        for (int i : PathFinder.NEIGHBOURS9) {
+            i = cell + i;
+            if (level.solid[i]) {
+                level.openSpace[i] = false;
+            } else {
+                for (int j = 1; j < PathFinder.CIRCLE8.length; j += 2) {
+                    if (level.solid[i + PathFinder.CIRCLE8[j]]) {
+                        level.openSpace[i] = false;
+                    } else if (!level.solid[i + PathFinder.CIRCLE8[(j + 1) % 8]]
+                            && !level.solid[i + PathFinder.CIRCLE8[(j + 2) % 8]]) {
+                        level.openSpace[i] = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    public Heap drop(Item item, int cell) {
+
+        if (item == null || Challenges.isItemBlocked(item)) {
+
+            //create a dummy heap, give it a dummy sprite, don't add it to the game, and return it.
+            //effectively nullifies whatever the logic calling this wants to do, including dropping items.
+            Heap heap = new Heap();
+            ItemSprite sprite = heap.sprite = new ItemSprite();
+            sprite.link(heap);
+            return heap;
+
+        }
+
+        Heap heap = heaps.get(cell);
+        if (heap == null) {
+
+            heap = new Heap();
+            heap.seen = Dungeon.level == this && heroFOV[cell];
+            heap.pos = cell;
+            heap.drop(item);
+            if (map[cell] == Terrain.CHASM || (Dungeon.level != null && pit[cell])) {
+                Dungeon.dropToChasm(item);
+                GameScene.discard(heap);
+            } else {
+                heaps.put(cell, heap);
+                GameScene.add(heap);
+            }
+
+        } else if (heap.type == Heap.Type.LOCKED_CHEST || heap.type == Heap.Type.CRYSTAL_CHEST) {
+
+            int n;
+            do {
+                n = cell + PathFinder.NEIGHBOURS8[Random.Int(8)];
+            } while (!passable[n] && !avoid[n]);
+            return drop(item, n);
+
+        } else {
+            heap.drop(item);
+        }
+
+        if (Dungeon.level != null && ShatteredPixelDungeon.scene() instanceof GameScene) {
+            pressCell(cell);
+        }
+
+        return heap;
+    }
+
+    public Plant plant(Plant.Seed seed, int pos) {
+
+        if (Dungeon.isChallenged(Challenges.NO_HERBALISM)) {
+            return null;
+        }
+
+        Plant plant = plants.get(pos);
+        if (plant != null) {
+            plant.wither();
+        }
+
+        if (map[pos] == Terrain.HIGH_GRASS ||
+                map[pos] == Terrain.FURROWED_GRASS ||
+                map[pos] == Terrain.EMPTY ||
+                map[pos] == Terrain.EMBERS ||
+                map[pos] == Terrain.EMPTY_DECO) {
+            set(pos, Terrain.GRASS, this);
+            GameScene.updateMap(pos);
+        }
+
+        plant = seed.couch(pos, this);
+        plants.put(pos, plant);
+
+        GameScene.plantSeed(pos);
+
+        for (Char ch : Actor.chars()) {
+            if (ch instanceof WandOfRegrowth.Lotus
+                    && ((WandOfRegrowth.Lotus) ch).inRange(pos)
+                    && Actor.findChar(pos) != null) {
+                plant.trigger();
+                return null;
+            }
+        }
+
+        return plant;
+    }
+
+    public void uproot(int pos) {
+        plants.remove(pos);
+        GameScene.updateMap(pos);
+    }
+
+    public Trap setTrap(Trap trap, int pos) {
+        Trap existingTrap = traps.get(pos);
+        if (existingTrap != null) {
+            traps.remove(pos);
+        }
+        trap.set(pos);
+        traps.put(pos, trap);
+        GameScene.updateMap(pos);
+        return trap;
+    }
+
+    public void disarmTrap(int pos) {
+        set(pos, Terrain.INACTIVE_TRAP);
+        GameScene.updateMap(pos);
+    }
+
+    public void discover(int cell) {
+        set(cell, Terrain.discover(map[cell]));
+        Trap trap = traps.get(cell);
+        if (trap != null)
+            trap.reveal();
+        GameScene.updateMap(cell);
+    }
+
+    public boolean setCellToWater(boolean includeTraps, int cell) {
+        Point p = cellToPoint(cell);
+
+        //if a custom tilemap is over that cell, don't put water there
+        for (CustomTilemap cust : customTiles) {
+            Point custPoint = new Point(p);
+            custPoint.x -= cust.tileX;
+            custPoint.y -= cust.tileY;
+            if (custPoint.x >= 0 && custPoint.y >= 0
+                    && custPoint.x < cust.tileW && custPoint.y < cust.tileH) {
+                if (cust.image(custPoint.x, custPoint.y) != null) {
+                    return false;
+                }
+            }
+        }
+
+        int terr = map[cell];
+        if (terr == Terrain.EMPTY || terr == Terrain.GRASS ||
+                terr == Terrain.EMBERS || terr == Terrain.EMPTY_SP ||
+                terr == Terrain.HIGH_GRASS || terr == Terrain.FURROWED_GRASS
+                || terr == Terrain.EMPTY_DECO) {
+            set(cell, Terrain.WATER);
+            GameScene.updateMap(cell);
+            return true;
+        } else if (includeTraps && (terr == Terrain.SECRET_TRAP ||
+                terr == Terrain.TRAP || terr == Terrain.INACTIVE_TRAP)) {
+            set(cell, Terrain.WATER);
+            Dungeon.level.traps.remove(cell);
+            GameScene.updateMap(cell);
+            return true;
+        }
+
+        return false;
+    }
+
+    public int fallCell(boolean fallIntoPit) {
+        int result;
+        do {
+            result = randomRespawnCell(null);
+            if (result == -1) return -1;
+        } while (traps.get(result) != null
+                || findMob(result) != null);
+        return result;
+    }
+
+    public void occupyCell(Char ch) {
+        if (!ch.isImmune(Web.class) && Blob.volumeAt(ch.pos, Web.class) > 0) {
+            blobs.get(Web.class).clear(ch.pos);
+            Web.affectChar(ch);
+        }
+
+        if (!ch.flying) {
+
+            if ((map[ch.pos] == Terrain.GRASS || map[ch.pos] == Terrain.EMBERS)
+                    && ch == Dungeon.hero && Dungeon.hero.hasTalent(Talent.REJUVENATING_STEPS)
+                    && ch.buff(Talent.RejuvenatingStepsCooldown.class) == null) {
+
+                if (Dungeon.hero.buff(LockedFloor.class) != null && !Dungeon.hero.buff(LockedFloor.class).regenOn()) {
+                    set(ch.pos, Terrain.FURROWED_GRASS);
+                } else if (ch.buff(Talent.RejuvenatingStepsFurrow.class) != null && ch.buff(Talent.RejuvenatingStepsFurrow.class).count() >= 200) {
+                    set(ch.pos, Terrain.FURROWED_GRASS);
+                } else {
+                    set(ch.pos, Terrain.HIGH_GRASS);
+                    Buff.count(ch, Talent.RejuvenatingStepsFurrow.class, 3 - Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));
+                }
+                GameScene.updateMap(ch.pos);
+                Buff.affect(ch, Talent.RejuvenatingStepsCooldown.class, 15f - 5f * Dungeon.hero.pointsInTalent(Talent.REJUVENATING_STEPS));
+            }
+
+            if (pit[ch.pos]) {
+                if (ch == Dungeon.hero) {
+                    Chasm.heroFall(ch.pos);
+                } else if (ch instanceof Mob) {
+                    Chasm.mobFall((Mob) ch);
+                }
+                return;
+            }
+
+            //characters which are not the hero or a sheep 'soft' press cells
+            pressCell(ch.pos, ch instanceof Hero || ch instanceof Sheep);
+        } else {
+            if (map[ch.pos] == Terrain.DOOR) {
+                Door.enter(ch.pos);
+            }
+        }
+
+        if (ch.isAlive() && ch instanceof Piranha && !water[ch.pos]) {
+            ch.die(null);
+        }
+    }
+
+    //public method for forcing the hard press of a cell. e.g. when an item lands on it
+    public void pressCell(int cell) {
+        pressCell(cell, true);
+    }
+
+    //a 'soft' press ignores hidden traps
+    //a 'hard' press triggers all things
+    private void pressCell(int cell, boolean hard) {
+
+        Trap trap = null;
+
+        switch (map[cell]) {
+
+            case Terrain.SECRET_TRAP:
+                if (hard) {
+                    trap = traps.get(cell);
+                    GLog.i(Messages.get(Level.class, "hidden_trap", trap.name()));
+                }
+                break;
+
+            case Terrain.TRAP:
+                trap = traps.get(cell);
+                break;
+
+            case Terrain.HIGH_GRASS:
+            case Terrain.FURROWED_GRASS:
+                HighGrass.trample(this, cell);
+                break;
+
+            case Terrain.WELL:
+                WellWater.affectCell(cell);
+                break;
+
+            case Terrain.DOOR:
+                Door.enter(cell);
+                break;
+        }
+
+        TimekeepersHourglass.timeFreeze timeFreeze =
+                Dungeon.hero.buff(TimekeepersHourglass.timeFreeze.class);
+
+        Swiftthistle.TimeBubble bubble =
+                Dungeon.hero.buff(Swiftthistle.TimeBubble.class);
+
+        if (trap != null) {
+            if (bubble != null) {
+                Sample.INSTANCE.play(Assets.Sounds.TRAP);
+                discover(cell);
+                bubble.setDelayedPress(cell);
+
+            } else if (timeFreeze != null) {
+                Sample.INSTANCE.play(Assets.Sounds.TRAP);
+                discover(cell);
+                timeFreeze.setDelayedPress(cell);
+
+            } else {
+                if (Dungeon.hero.pos == cell) {
+                    Dungeon.hero.interrupt();
+                }
+                trap.trigger();
+
+            }
+        }
+
+        Plant plant = plants.get(cell);
+        if (plant != null) {
+            if (bubble != null) {
+                Sample.INSTANCE.play(Assets.Sounds.TRAMPLE, 1, Random.Float(0.96f, 1.05f));
+                bubble.setDelayedPress(cell);
+
+            } else if (timeFreeze != null) {
+                Sample.INSTANCE.play(Assets.Sounds.TRAMPLE, 1, Random.Float(0.96f, 1.05f));
+                timeFreeze.setDelayedPress(cell);
+
+            } else {
+                plant.trigger();
+
+            }
+        }
+
+        if (hard && Blob.volumeAt(cell, Web.class) > 0) {
+            blobs.get(Web.class).clear(cell);
+        }
+    }
+
+    private static boolean[] heroMindFov;
+
+    private static boolean[] modifiableBlocking;
+
+    public void updateFieldOfView(Char c, boolean[] fieldOfView) {
+
+        int cx = c.pos % width();
+        int cy = c.pos / width();
+
+        boolean sighted = c.buff(Blindness.class) == null && c.buff(Shadows.class) == null
+                && c.buff(TimekeepersHourglass.timeStasis.class) == null && c.isAlive();
+        if (sighted) {
+            boolean[] blocking = null;
+
+            if (modifiableBlocking == null || modifiableBlocking.length != Dungeon.level.losBlocking.length) {
+                modifiableBlocking = new boolean[Dungeon.level.losBlocking.length];
+            }
+
+            if ((c instanceof Hero && ((Hero) c).subClass == HeroSubClass.WARDEN)
+                    || c instanceof YogFist.SoiledFist) {
+                if (blocking == null) {
+                    System.arraycopy(Dungeon.level.losBlocking, 0, modifiableBlocking, 0, modifiableBlocking.length);
+                    blocking = modifiableBlocking;
+                }
+                for (int i = 0; i < blocking.length; i++) {
+                    if (blocking[i] && (Dungeon.level.map[i] == Terrain.HIGH_GRASS || Dungeon.level.map[i] == Terrain.FURROWED_GRASS)) {
+                        blocking[i] = false;
+                    }
+                }
+            }
+
+            if (c.alignment != Char.Alignment.ALLY
+                    && Dungeon.level.blobs.containsKey(SmokeScreen.class)
+                    && Dungeon.level.blobs.get(SmokeScreen.class).volume > 0) {
+                if (blocking == null) {
+                    System.arraycopy(Dungeon.level.losBlocking, 0, modifiableBlocking, 0, modifiableBlocking.length);
+                    blocking = modifiableBlocking;
+                }
+                Blob s = Dungeon.level.blobs.get(SmokeScreen.class);
+                for (int i = 0; i < blocking.length; i++) {
+                    if (!blocking[i] && s.cur[i] > 0) {
+                        blocking[i] = true;
+                    }
+                }
+            }
+
+            if (blocking == null) {
+                blocking = Dungeon.level.losBlocking;
+            }
+
+            int viewDist = c.viewDistance;
+            if (c instanceof Hero) {
+                viewDist *= 1f + 0.25f * ((Hero) c).pointsInTalent(Talent.FARSIGHT);
+            }
+
+            ShadowCaster.castShadow(cx, cy, fieldOfView, blocking, viewDist);
+        } else {
+            BArray.setFalse(fieldOfView);
+        }
+
+        int sense = 1;
+        //Currently only the hero can get mind vision
+        if (c.isAlive() && c == Dungeon.hero) {
+            for (Buff b : c.buffs(MindVision.class)) {
+                sense = Math.max(((MindVision) b).distance, sense);
+            }
+            if (c.buff(MagicalSight.class) != null) {
+                sense = Math.max(MagicalSight.DISTANCE, sense);
+            }
+        }
+
+        //uses rounding
+        if (!sighted || sense > 1) {
+
+            int[][] rounding = ShadowCaster.rounding;
+
+            int left, right;
+            int pos;
+            for (int y = Math.max(0, cy - sense); y <= Math.min(height() - 1, cy + sense); y++) {
+                if (rounding[sense][Math.abs(cy - y)] < Math.abs(cy - y)) {
+                    left = cx - rounding[sense][Math.abs(cy - y)];
+                } else {
+                    left = sense;
+                    while (rounding[sense][left] < rounding[sense][Math.abs(cy - y)]) {
+                        left--;
+                    }
+                    left = cx - left;
+                }
+                right = Math.min(width() - 1, cx + cx - left);
+                left = Math.max(0, left);
+                pos = left + y * width();
+                System.arraycopy(discoverable, pos, fieldOfView, pos, right - left + 1);
+            }
+        }
+
+        if (c instanceof SpiritHawk.HawkAlly && Dungeon.hero.pointsInTalent(Talent.EAGLE_EYE) >= 3) {
+            int range = 1 + (Dungeon.hero.pointsInTalent(Talent.EAGLE_EYE) - 2);
+            for (Mob mob : mobs) {
+                int p = mob.pos;
+                if (!fieldOfView[p] && distance(c.pos, p) <= range) {
+                    for (int i : PathFinder.NEIGHBOURS9) {
+                        fieldOfView[mob.pos + i] = true;
+                    }
+                }
+            }
+        }
+
+        //Currently only the hero can get mind vision or awareness
+        if (c.isAlive() && c == Dungeon.hero) {
+
+            if (heroMindFov == null || heroMindFov.length != length()) {
+                heroMindFov = new boolean[length];
+            } else {
+                BArray.setFalse(heroMindFov);
+            }
+
+            Dungeon.hero.mindVisionEnemies.clear();
+            if (c.buff(MindVision.class) != null) {
+                for (Mob mob : mobs) {
+                    for (int i : PathFinder.NEIGHBOURS9) {
+                        heroMindFov[mob.pos + i] = true;
+                    }
+                }
+            } else if (((Hero) c).hasTalent(Talent.HEIGHTENED_SENSES)) {
+                Hero h = (Hero) c;
+                int range = 1 + h.pointsInTalent(Talent.HEIGHTENED_SENSES);
+                for (Mob mob : mobs) {
+                    int p = mob.pos;
+                    if (!fieldOfView[p] && distance(c.pos, p) <= range) {
+                        for (int i : PathFinder.NEIGHBOURS9) {
+                            heroMindFov[mob.pos + i] = true;
+                        }
+                    }
+                }
+            }
+
+            if (c.buff(Awareness.class) != null) {
+                for (Heap heap : heaps.valueList()) {
+                    int p = heap.pos;
+                    for (int i : PathFinder.NEIGHBOURS9) heroMindFov[p + i] = true;
+                }
+            }
+
+            for (TalismanOfForesight.CharAwareness a : c.buffs(TalismanOfForesight.CharAwareness.class)) {
+                Char ch = (Char) Actor.findById(a.charID);
+                if (ch == null || !ch.isAlive()) {
+                    continue;
+                }
+                int p = ch.pos;
+                for (int i : PathFinder.NEIGHBOURS9) heroMindFov[p + i] = true;
+            }
+
+            for (TalismanOfForesight.HeapAwareness h : c.buffs(TalismanOfForesight.HeapAwareness.class)) {
+                if (Dungeon.depth != h.depth) continue;
+                for (int i : PathFinder.NEIGHBOURS9) heroMindFov[h.pos + i] = true;
+            }
+
+            for (Mob m : mobs) {
+                if (m instanceof WandOfWarding.Ward
+                        || m instanceof WandOfRegrowth.Lotus
+                        || m instanceof SpiritHawk.HawkAlly) {
+                    if (m.fieldOfView == null || m.fieldOfView.length != length()) {
+                        m.fieldOfView = new boolean[length()];
+                        Dungeon.level.updateFieldOfView(m, m.fieldOfView);
+                    }
+                    BArray.or(heroMindFov, m.fieldOfView, heroMindFov);
+                }
+            }
+
+            for (RevealedArea a : c.buffs(RevealedArea.class)) {
+                if (Dungeon.depth != a.depth) continue;
+                for (int i : PathFinder.NEIGHBOURS9) heroMindFov[a.pos + i] = true;
+            }
+
+            //set mind vision chars
+            for (Mob mob : mobs) {
+                if (heroMindFov[mob.pos] && !fieldOfView[mob.pos]) {
+                    Dungeon.hero.mindVisionEnemies.add(mob);
+                }
+            }
+
+            BArray.or(heroMindFov, fieldOfView, fieldOfView);
+
+        }
+
+        if (c == Dungeon.hero) {
+            for (Heap heap : heaps.valueList())
+                if (!heap.seen && fieldOfView[heap.pos])
+                    heap.seen = true;
+        }
+
+    }
+
+    public boolean isLevelExplored(int depth) {
+        return false;
+    }
+
+    public int distance(int a, int b) {
+        int ax = a % width();
+        int ay = a / width();
+        int bx = b % width();
+        int by = b / width();
+        return Math.max(Math.abs(ax - bx), Math.abs(ay - by));
+    }
+
+    public boolean adjacent(int a, int b) {
+        return distance(a, b) == 1;
+    }
+
+    //uses pythagorean theorum for true distance, as if there was no movement grid
+    public float trueDistance(int a, int b) {
+        int ax = a % width();
+        int ay = a / width();
+        int bx = b % width();
+        int by = b / width();
+        return (float) Math.sqrt(Math.pow(Math.abs(ax - bx), 2) + Math.pow(Math.abs(ay - by), 2));
+    }
+
+    //returns true if the input is a valid tile within the level
+    public boolean insideMap(int tile) {
+        //top and bottom row and beyond
+        return !((tile < width || tile >= length - width) ||
+                //left and right column
+                (tile % width == 0 || tile % width == width - 1));
+    }
+
+    public Point cellToPoint(int cell) {
+        return new Point(cell % width(), cell / width());
+    }
+
+    public int pointToCell(Point p) {
+        return p.x + p.y * width();
+    }
+
+    public String tileName(int tile) {
+
+        switch (tile) {
+            case Terrain.CHASM:
+                return Messages.get(Level.class, "chasm_name");
+            case Terrain.EMPTY:
+            case Terrain.EMPTY_SP:
+            case Terrain.EMPTY_DECO:
+            case Terrain.SECRET_TRAP:
+                return Messages.get(Level.class, "floor_name");
+            case Terrain.GRASS:
+                return Messages.get(Level.class, "grass_name");
+            case Terrain.WATER:
+                return Messages.get(Level.class, "water_name");
+            case Terrain.WALL:
+            case Terrain.WALL_DECO:
+            case Terrain.SECRET_DOOR:
+                return Messages.get(Level.class, "wall_name");
+            case Terrain.DOOR:
+                return Messages.get(Level.class, "closed_door_name");
+            case Terrain.OPEN_DOOR:
+                return Messages.get(Level.class, "open_door_name");
+            case Terrain.ENTRANCE:
+                return Messages.get(Level.class, "entrace_name");
+            case Terrain.EXIT:
+                return Messages.get(Level.class, "exit_name");
+            case Terrain.EMBERS:
+                return Messages.get(Level.class, "embers_name");
+            case Terrain.FURROWED_GRASS:
+                return Messages.get(Level.class, "furrowed_grass_name");
+            case Terrain.LOCKED_DOOR:
+                return Messages.get(Level.class, "locked_door_name");
+            case Terrain.CRYSTAL_DOOR:
+                return Messages.get(Level.class, "crystal_door_name");
+            case Terrain.PEDESTAL:
+                return Messages.get(Level.class, "pedestal_name");
+            case Terrain.BARRICADE:
+                return Messages.get(Level.class, "barricade_name");
+            case Terrain.HIGH_GRASS:
+                return Messages.get(Level.class, "high_grass_name");
+            case Terrain.LOCKED_EXIT:
+                return Messages.get(Level.class, "locked_exit_name");
+            case Terrain.UNLOCKED_EXIT:
+                return Messages.get(Level.class, "unlocked_exit_name");
+            case Terrain.SIGN:
+                return Messages.get(Level.class, "sign_name");
+            case Terrain.WELL:
+                return Messages.get(Level.class, "well_name");
+            case Terrain.EMPTY_WELL:
+                return Messages.get(Level.class, "empty_well_name");
+            case Terrain.STATUE:
+            case Terrain.STATUE_SP:
+                return Messages.get(Level.class, "statue_name");
+            case Terrain.INACTIVE_TRAP:
+                return Messages.get(Level.class, "inactive_trap_name");
+            case Terrain.BOOKSHELF:
+                return Messages.get(Level.class, "bookshelf_name");
+            case Terrain.ALCHEMY:
+                return Messages.get(Level.class, "alchemy_name");
+            default:
+                return Messages.get(Level.class, "default_name");
+        }
+    }
+
+    public String tileDesc(int tile) {
+
+        switch (tile) {
+            case Terrain.CHASM:
+                return Messages.get(Level.class, "chasm_desc");
+            case Terrain.WATER:
+                return Messages.get(Level.class, "water_desc");
+            case Terrain.ENTRANCE:
+                return Messages.get(Level.class, "entrance_desc");
+            case Terrain.EXIT:
+            case Terrain.UNLOCKED_EXIT:
+                return Messages.get(Level.class, "exit_desc");
+            case Terrain.EMBERS:
+                return Messages.get(Level.class, "embers_desc");
+            case Terrain.HIGH_GRASS:
+            case Terrain.FURROWED_GRASS:
+                return Messages.get(Level.class, "high_grass_desc");
+            case Terrain.LOCKED_DOOR:
+                return Messages.get(Level.class, "locked_door_desc");
+            case Terrain.CRYSTAL_DOOR:
+                return Messages.get(Level.class, "crystal_door_desc");
+            case Terrain.LOCKED_EXIT:
+                return Messages.get(Level.class, "locked_exit_desc");
+            case Terrain.BARRICADE:
+                return Messages.get(Level.class, "barricade_desc");
+            case Terrain.SIGN:
+                return Messages.get(Level.class, "sign_desc");
+            case Terrain.INACTIVE_TRAP:
+                return Messages.get(Level.class, "inactive_trap_desc");
+            case Terrain.STATUE:
+            case Terrain.STATUE_SP:
+                return Messages.get(Level.class, "statue_desc");
+            case Terrain.ALCHEMY:
+                return Messages.get(Level.class, "alchemy_desc");
+            case Terrain.EMPTY_WELL:
+                return Messages.get(Level.class, "empty_well_desc");
+            default:
+                return "";
+        }
+    }
 }
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
index 4305dfa4a..630953b0d 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/levels/editor/CustomTestLevel.java
@@ -1,6 +1,7 @@
 package com.shatteredpixel.shatteredpixeldungeon.levels.editor;
 
 import com.shatteredpixel.shatteredpixeldungeon.Assets;
+import com.shatteredpixel.shatteredpixeldungeon.Dungeon;
 import com.shatteredpixel.shatteredpixeldungeon.actors.Actor;
 import com.shatteredpixel.shatteredpixeldungeon.actors.Char;
 import com.shatteredpixel.shatteredpixeldungeon.actors.mobs.DwarfKing;
@@ -22,17 +23,18 @@ import com.watabou.utils.Point;
 public class CustomTestLevel extends Level {
 
     private final int width = 10, height = 10;
-    private  final  int[] terrains = {
+
+    private final int[] terrains = {
             WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL,
             WALL, WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
             WALL, WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
-            WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EXIT, EMPTY, WALL,
             WALL, WATER, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WATER, EMPTY, WALL,
             WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, ENTRANCE, EMPTY, WALL,
             WALL, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
-            WALL, WALL, WALL, WALL, WALL, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
+            WALL, WALL, WALL, WALL, WALL, EMPTY, EMPTY, EMPTY, EXIT, WALL,
             WALL, EXIT, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, EMPTY, WALL,
-            WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL
+            WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL, WALL,
     };
 
 
@@ -55,6 +57,7 @@ public class CustomTestLevel extends Level {
     protected boolean build() {
 
         setSize(width, height);
+        terrains[54] = Dungeon.depth;
 
 
         for (int i = 0; i < terrains.length; i++) {
@@ -65,10 +68,21 @@ public class CustomTestLevel extends Level {
 
         return true;
     }
-    protected  void  addTransitios(){
+
+    protected void addTransitios() {
+        int curBranch = Dungeon.branch;
         for (int i = 0; i < terrains.length; i++) {
-            if (terrains[i] == ENTRANCE) transitions.add(new LevelTransition(this, i,LevelTransition.Type.SURFACE));
-            else if (terrains[i] == EXIT) transitions.add(new LevelTransition(this, i,LevelTransition.Type.REGULAR_EXIT));
+            if (terrains[i] == ENTRANCE){
+                LevelTransition transition = new LevelTransition(this, i, Dungeon.depth == 1 ? LevelTransition.Type.SURFACE : LevelTransition.Type.REGULAR_ENTRANCE);
+//                transition.destBranch = parentBranch;
+                transitions.add(transition);
+            }
+            else if (terrains[i] == EXIT) {
+                LevelTransition transition = new LevelTransition(this, i, LevelTransition.Type.REGULAR_EXIT);
+                transition.destBranch = curBranch;
+                transitions.add(transition);
+                curBranch++;
+            }
         }
     }
 
@@ -79,21 +93,24 @@ public class CustomTestLevel extends Level {
 
     @Override
     protected void createMobs() {
-       Mob m1 = new Rat();
-       m1.pos=25;
-       mobs.add(m1);
+        Mob m1 = new Rat();
+        m1.pos = 25;
+        mobs.add(m1);
 
         Mob m2 = new Imp();
-        m2.pos=45;
+        m2.pos = 45;
         mobs.add(m2);
+        Mob m4 = new Imp();
+        m4.pos = 46;
+        mobs.add(m4);
+
         Mob m3 = new Scorpio();
-        m3.pos=83;
+        m3.pos = 83;
 
-        m3.paralysed=5000;
-        m3.invisible=10;
-        m3.damage(50,null);
+        m3.paralysed = 5000;
+        m3.invisible = 10;
 
-        mobs.add(m3);
+//        mobs.add(m3);
     }
 
 
@@ -104,8 +121,7 @@ public class CustomTestLevel extends Level {
     @Override
     protected void createItems() {
 
-        drop(new Torch(),21);
-
+        drop(new Torch(), 21);
 
     }
 
diff --git a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java
index 324bc904a..b0dae4ace 100644
--- a/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java
+++ b/core/src/main/java/com/shatteredpixel/shatteredpixeldungeon/scenes/InterlevelScene.java
@@ -387,6 +387,7 @@ public class InterlevelScene extends PixelScene {
 
 			Level level;
 			Dungeon.depth = curTransition.destDepth;
+			Dungeon.prevBranch=Dungeon.branch;
 			Dungeon.branch = curTransition.destBranch;
 			//TODO this is brittle atm, assumes we're always going down in depth 1 at a time
 			if (curTransition.destDepth > Statistics.deepestFloor) {
@@ -426,6 +427,7 @@ public class InterlevelScene extends PixelScene {
 
 		Dungeon.saveAll();
 		Dungeon.depth = curTransition.destDepth;
+		Dungeon.prevBranch=Dungeon.branch;
 		Dungeon.branch = curTransition.destBranch;
 		Level level = Dungeon.loadLevel( GamesInProgress.curSlot );
 
@@ -440,6 +442,7 @@ public class InterlevelScene extends PixelScene {
 
 		Dungeon.saveAll();
 		Dungeon.depth = returnDepth;
+		Dungeon.prevBranch=Dungeon.branch;
 		Dungeon.branch = returnBranch;
 		Level level = Dungeon.loadLevel( GamesInProgress.curSlot );
 		Dungeon.switchLevel( level, returnPos );
-- 
2.37.1.windows.1

